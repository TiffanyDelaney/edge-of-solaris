/* autogenerated by Processing revision 1277 on 2022-01-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class edge_of_solaris extends PApplet {

bullet[] blts;
enemy[] basicE;
starsBG[] stars;



 public void setup(){
  /* size commented out by preprocessor */;
  blts = new bullet[bulletCount];
  basicE = new enemy[basicECount];
  stars = new starsBG[starCount];
  initObjects(); //initializes all objects to "default" values
  loadText(); //load the text file for visual novel text
}

 public void draw() {
  background(0);
  processInput();
  drawFrame();
  drawUI();
  if (screenIndex == 0) {
    basicE[0].enemyX = 500;
    basicE[0].enemyY = 200;
    basicE[0].enemySpeedX = 0;
    basicE[0].enemySpeedY = 0;
    basicE[0].enemyType = 0;
    basicE[0].enemyHitX = 25;
    basicE[0].enemyHitY = 25;
    basicE[0].enemyState = 0;
        
    basicE[1].enemyX = 300;
    basicE[1].enemyY = 400;
    basicE[1].enemySpeedX = 0;
    basicE[1].enemySpeedY = 0;
    basicE[1].enemyType = 0;
    basicE[1].enemyHitX = 25;
    basicE[1].enemyHitY = 25;
    basicE[1].enemyState = 0;
    
    basicE[2].enemyX = 700;
    basicE[2].enemyY = 400;
    basicE[2].enemySpeedX = 0;
    basicE[2].enemySpeedY = 0;
    basicE[2].enemyType = 0;
    basicE[2].enemyHitX = 25;
    basicE[2].enemyHitY = 25;
    basicE[2].enemyState = 0;
    
    basicE[3].enemyX = 9000;
    basicE[3].enemyY = 20;
    basicE[3].enemySpeedX = 0;
    basicE[3].enemySpeedY = 0;
    basicE[3].enemyType = 0;
    basicE[3].enemyHitX = 25;
    basicE[3].enemyHitY = 25;
    basicE[3].enemyState = 0;
    
    basicE[4].enemyX = 600;
    basicE[4].enemyY = 20;
    basicE[4].enemySpeedX = 0;
    basicE[4].enemySpeedY = 0;
    basicE[4].enemyType = 0;
    basicE[4].enemyHitX = 25;
    basicE[4].enemyHitY = 25;
    basicE[4].enemyState = 0;
  }
  if (timing < 255) timing++;
}

 public void drawFrame() {
  if (screenIndex == 0) {
    for (starsBG stars : stars) {
      stars.update();
      stars.display();
    }
    for (enemy basicE : basicE) {
      basicE.collision();
      basicE.shoot();
      basicE.update();
      basicE.display();
    }
    for (bullet blts : blts) {
      blts.update();
      blts.display();
    }
    
    //draw player
    playerCollision();
    if (playerShield < playerShieldMax) playerShield = playerShield + playerShieldRegen; //regen shield if depleted
    if (playerShield > playerShieldMax) playerShield = playerShieldMax; //ensure shield does not increase past max
    if (playerState == 0) setRect(1); //if player not being hurt
    else if (playerState == 1) setRect(2); //if player being hurt
    rect(playerX, playerY, 60, 20); //render player model
    playerState = 0; // reset player state after hit/render
  } else if (screenIndex == 1) {
    resetObjects(); //reset objects on non game screens 
  } else if (screenIndex == 3) {
    drawVN();
  }
}

 public void drawUI() {
  if (screenIndex == 0) { //in game
    textSize(64);
    fill(255);
    text("Q and E switch weapons", 50, 600);
    //render hp and shield bars
    setRect(3);
    rect(20, 650, 200, 50);
    rect(235, 650, 200, 50);
    setRect(4);
    rect(23, 653, (194 * (playerHP / playerHPMax)), 44);
    setRect(5);
    rect(238, 653, (194 * (playerShield / playerShieldMax)), 44);
  } else if (screenIndex == 1) { //title page
    fill(200, 200, 255, 120);
    textSize(130);
    text("Edge Of Solaris", 240, 120);
    text("Edge Of Solaris", 248, 120);
    fill(200, 200, 255, 255);
    textSize(128);
    text("Edge Of Solaris", 250, 120);
    fill(200, 200, 255);
    textSize(90);
    text("random bullshit in space", 200, 240);
    textSize(64);
    text("new game", 500, 400);
    text("continue", 500, 500);
    text("press space to continue (temp)", 50, 650);
  } else if (screenIndex == 2) { //level select
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    rect(950, 25, 300, 75);
    rect(950, 125, 300, 75);
    rect(950, 225, 300, 75);
    rect(950, 325, 300, 75);
    noStroke();
    fill(255);
    textSize(48);
    text("status", 975, 75);
    text("mess hall", 975, 175);
    text("hanger", 975, 275);
    text("engineering", 975, 375);
    text("press w to continue (temp)", 50, 650);
  }
}

 public void setRect(int colorIndex) {
  if (colorIndex == 0) {
    strokeWeight(1);
    noStroke();
    fill(0);
  } else if (colorIndex == 1) { //used for player ship rendering
    strokeWeight(1);
    noStroke();
    fill(255);
  } else if (colorIndex == 2) { //used for player hurt rendering
    strokeWeight(5);
    stroke(200, 0, 0, 100);
    fill(255, 200, 200);
  } else if (colorIndex == 3) { //used for hp surround
    strokeWeight(6);
    fill(0);
    stroke(255);
  } else if (colorIndex == 4) { //used for hp bar fill
    noStroke();
    fill(20, 255, 20);
  } else if (colorIndex == 5) {
    noStroke();
    fill(20, 20, 255);
  }
}

 public void initObjects() { //set all objects to default (meant to be run in setup)
  for (int i = 0; i < bulletCount; i++) {
    blts[i] = new bullet(-20, -20, 0, 0, 255, 0, 0, 0);
  }
  for (int i = 0; i < basicECount; i++) {
    basicE[i] = new enemy(-200, -200, 0, 0, 99, 0, 0, 10, 10, 0, 2);
  }
  for (int i = 0; i < starCount; i++) {
    stars[i] = new starsBG(PApplet.parseInt(random(screenX + 20)), PApplet.parseInt(random(screenY)), PApplet.parseInt(-1 * (random(10) + 1)), 0);
  }
}

 public void resetObjects() { //resets objects (similar to init but meant to be run in main loop)
    for (starsBG stars : stars) {
      stars.reset();
    }
    for (enemy basicE : basicE) {
      basicE.reset();
    }
    for (bullet blts : blts) {
      blts.reset();
    }
}

 public void playerCollision() { //check to see if an enemy bullet 
    for (int i = 0; i < bulletCount; i++) {
   if (blts[i].bulletType == 200 || blts[i].bulletType == 201) { //check to ensure bullet is an enemy bullet
    if (playerX <= blts[i].bulletX + (blts[i].bulletHitX / 2)) {
      //println(( enemyX + (enemyHitX / 2)) + " + " + (blts[i].bulletX +  (blts[i].bulletHitX / 2)));
      if ((playerX + (playerHitX / 1)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (playerY <= blts[i].bulletY + (blts[i].bulletHitY / 2)) {
          if ((playerY + (playerHitY / 1)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
            if (blts[i].bulletType == 200 || blts[i].bulletType == 201) {
              playerState = 1;
              playerShield = playerShield - blts[i].bulletPower;
              if (playerShield < 0) { //if shield goes negative
                playerHP = playerHP - abs(playerShield); //subtract the difference of how negative the shield is
                playerShield = 0; //make sure player shield does not go negative
              }
            }
            if (blts[i].bulletType == 200) blts[i].reset();
          }
        }
      }
    }
  }
  }
}
class bullet {
  float bulletX; //bullet x pos
  float bulletY; //bullet y pos
  float bulletSpeedX; //bullet x speed
  float bulletSpeedY; //bullet y speed
  int bulletType; //255 = dead/inactive bullet, 0-199 = player bullets, 200-254 = enemy bullets
  int bulletHitX; //bullet hitbox x
  int bulletHitY; //bullet hitbox y
  int bulletPower; //bullet impact damage (defined on bullet gen)

bullet(float bulletXtemp, float bulletYtemp, float bulletSpeedXtemp, float bulletSpeedYtemp, int bulletTypetemp, int bulletHitXtemp, int bulletHitYtemp, int bulletPowertemp) {
  bulletX = bulletXtemp;
  bulletY = bulletYtemp;
  bulletSpeedX = bulletSpeedXtemp;
  bulletSpeedY = bulletSpeedYtemp;
  bulletType = bulletTypetemp;
  bulletHitX = bulletHitXtemp;
  bulletHitY = bulletHitYtemp;
  bulletPower = bulletPowertemp;
}

 public void update() {
  if (bulletX > (screenX + 100) || bulletX < -100 || bulletY > (screenY + 100) || bulletY < -100) bulletType = 255; //destroy bullet if off screen
  else { //if bullet is not off screen, update bullet position
    bulletX = bulletX + bulletSpeedX; //update bullet x according to x speed
    bulletY = bulletY + bulletSpeedY; //update bullet y according to y speed
  }
}

public void reset() {
  bulletX = -20;
  bulletY = -20;
  bulletSpeedX = 0;
  bulletSpeedY = 0;
  bulletType = 255;
  bulletHitX = 0;
  bulletHitY = 0;
  bulletPower = 0;
}

 public void explode() {
}

 public void display() {
  if (bulletType == 0) { //machine gun
    stroke(20, 20, 200, 120);
    strokeWeight(2);
    fill(20, 20, 200);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }
  else if (bulletType == 4) { //snipe shot
    stroke(255, 120);
    strokeWeight(10);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }
  else if (bulletType == 200) { //basic enemy shot
    stroke(255, 20, 20, 120);
    strokeWeight(2);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }
}
}
class enemy {
  int enemyX; //enemy x pos
  int enemyY; //enemy y pos
  int enemySpeedX; //enemy x speed
  int enemySpeedY; //enemy y speed
  int enemyType; //type of enemy, 0 = basic
  int enemyHitX; //enemy hitbox x
  int enemyHitY; //enemy hitbox y
  float enemyHP; //enemy current hp
  float enemyHPMax; //enemy max hp
  int enemyTiming; //enemy timing, used for projectile shot timing
  int enemyState; //0 = normal, 1 = hurt, 2 = dead

enemy(int enemyXtemp, int enemyYtemp, int enemySpeedXtemp, int enemySpeedYtemp, int enemyTypetemp, int enemyHitXtemp, int enemyHitYtemp, float enemyHPtemp, float enemyHPMaxtemp, int enemyTimingtemp, int enemyStatetemp) {
  enemyX = enemyXtemp;
  enemyY = enemyYtemp;
  enemySpeedX = enemySpeedXtemp;
  enemySpeedY = enemySpeedYtemp;
  enemyType = enemyTypetemp;
  enemyHitX = enemyHitXtemp;
  enemyHitY = enemyHitYtemp;
  enemyHP = enemyHPtemp;
  enemyHPMax = enemyHPMaxtemp;
  enemyTiming = enemyTimingtemp;
  enemyState = enemyStatetemp;
}

 public void update() {
  enemyX = enemyX + enemySpeedX; //update enemy x pos according to speed
  enemyY = enemyY + enemySpeedY; //update enemy y pos according to speed
  if (enemyTiming < 255) enemyTiming++; //increment enemy timer (used for timing enemy firing
  if (enemyHP <= 0) enemyState = 2; //set enemy as dead if hp is zero
}

 public void collision() {
  for (int i = 0; i < bulletCount; i++) { //run for every bullet instance
   if (blts[i].bulletType != 255) { //check to ensure bullet is not inactive (for efficiency)
    if (enemyX - (enemyHitX / 2) <= blts[i].bulletX - (blts[i].bulletHitX / 2)) {
      //println(( enemyX + (enemyHitX / 2)) + " + " + (blts[i].bulletX +  (blts[i].bulletHitX / 2)));
      if ((enemyX + (enemyHitX / 2)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (enemyY - (enemyHitY / 2) <= blts[i].bulletY - (blts[i].bulletHitY / 2)) {
          if ((enemyY + (enemyHitY / 2)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
            if (blts[i].bulletType == 0 || blts[i].bulletType == 4) { //check if bullet type is player projectile
              enemyState = 1; //change enemy to hurt state
              enemyHP = enemyHP - blts[i].bulletPower; //reduce enemy hp per bullet power
            }
            if (blts[i].bulletType == 0) blts[i].reset(); //reset bullet on impact if not snipe shot
          }
        }
      }
    }
  }
  }
}

 public void reset() {
  enemyX = -250;
  enemyY = -250;
  enemySpeedX = 0;
  enemySpeedY = 0;
  enemyType = 0;
  enemyHitX = 0;
  enemyHitY = 0;
  enemyHP = 0;
  enemyHPMax = 0;
  enemyState = 2; //dead
}

 public void hit(int bulletType) {
  //TEMP
}

 public void shoot() {
    if (enemyType == 0 && enemyState != 2) { //check to see if enemy is basic and not dead
    if (enemyTiming > 40) { //check to make sure enough time has passed since last shot
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (blts[i].bulletType == 255) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (bulletCount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
    float speed = 10; //higher numbers are slower
    int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
    int offsetY = 10; //account for incorrect aim
    float c = sqrt((abs(playerX - enemyX + offsetX)) + abs((playerY - enemyY + offsetY))); //solve for hypotenuse
    c = c * speed; //scale c (distance hypotenuse) to speed
    float speedX = (playerX - enemyX + offsetX);
    float speedY = (playerY - enemyY + offsetY);
    speedX = speedX / (c);
    speedY = speedY / (c);
    blts[bulletIndex] = new bullet(enemyX, enemyY, speedX, speedY, 200, 10, 10, 10);
    enemyTiming = 0;
    }
  }
}

 public void display() {
  strokeWeight(1);
  noStroke();
  if (enemyState != 2) { //do not display hp bar if enemy is dead
    fill(20, 255, 20, 100);
    rect(enemyX - 10, enemyY - 20, (20 * (enemyHP / enemyHPMax)), 5);
  }
  fill(255, 0, 0);
  if (enemyState == 1) {
    fill(0, 255, 0);
  } else if (enemyState == 2) {
    fill(255, 255, 0);
  }
  ellipse(enemyX, enemyY, 25, 25);
}
}
 public void loadText() {
  String[] lines = loadStrings("text.txt");
  for (int i = 0 ; i < lines.length; i++) {
    println(lines[i]);
    textLines[i] = lines[i];
  }
}
 public void processInput() {
  if (screenIndex == 0) {
      if (keyInput[0] == true) { //w
        playerY = playerY - playerMoveY;
      }
      if (keyInput[1] == true) { //s
        playerY = playerY + playerMoveY;
      }
      if (keyInput[2] == true) { //d
        playerX = playerX + playerMoveX;
      }
      if (keyInput[3] == true) { //a
        playerX = playerX - playerMoveX;
      }
      if (keyInput[4] == true) { //space
        playerShoot();
      }
      if (keyInput[5] == true) { //q, prev weapon
        playerWeapon = 0;
      }
      if (keyInput[6] == true) { //q, next weapon
        playerWeapon = 4;
      }
  }
  if (screenIndex == 1) {
    if (keyInput[4] == true) screenIndex = 2;
  }
  if (screenIndex == 2) {
    if (keyInput[0] == true) {
      screenIndex = 0;
      initObjects();
    }  
  }
}

 public void keyPressed() {
  if (key == 'w' || key == 'W')  keyInput[0] = true;
  if (key == 's' || key == 'S')  keyInput[1] = true;
  if (key == 'd' || key == 'D')  keyInput[2] = true;
  if (key == 'a' || key == 'A')  keyInput[3] = true;
  if (key == ' ') keyInput[4] = true;
  if (key == 'q' || key == 'Q')  keyInput[5] = true;
  if (key == 'e' || key == 'E')  keyInput[6] = true;
}

 public void keyReleased() {
  if (key == 'w' || key == 'W')  keyInput[0] = false;
  if (key == 's' || key == 'S')  keyInput[1] = false;
  if (key == 'd' || key == 'D')  keyInput[2] = false;
  if (key == 'a' || key == 'A')  keyInput[3] = false;
  if (key == ' ') keyInput[4] = false;
  if (key == 'q' || key == 'Q')  keyInput[5] = false;
  if (key == 'e' || key == 'E')  keyInput[6] = false;
}

 public void playerShoot() {
  if (playerWeapon == 0) { //machine gun
    if (timing > 10) {
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (blts[i].bulletType == 255) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > bulletCount) {
        bulletIndex = 0;
        exit = true;
      }
    }
    blts[bulletIndex] = new bullet(playerX + 55, playerY + 9, 5, 0, playerWeapon, 10, 10, 5);
    timing = 0;
    }
  }
  if (playerWeapon == 4) { //sniper shot
    if (timing > 30) {
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (blts[i].bulletType == 255) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > bulletCount) {
        bulletIndex = 0;
        exit = true;
      }
    }
    blts[bulletIndex] = new bullet(playerX + 55, playerY + 9, 25, 0, playerWeapon, 100, 10, 5);
    timing = 0;
    }
  }
}
class starsBG {
  int starX;
  int starY;
  int starSpeedX;
  int starSpeedY;

starsBG(int starXtemp, int starYtemp, int starSpeedXtemp, int starSpeedYtemp) {
  starX = starXtemp;
  starY = starYtemp;
  starSpeedX = starSpeedXtemp;
  starSpeedY = starSpeedYtemp;
}

 public void update() {
  starX = starX + starSpeedX;
  starY = starY + starSpeedY;
  if (starX < 0) {
    starY = PApplet.parseInt(random(screenY));
    starX = screenX + 20;
    starSpeedX = PApplet.parseInt(-1 * (random(10) + 1));
  }
}

 public void reset() {
  starX = -200;
  starY = -200;
  starSpeedX = 0;
  starSpeedY = 0;
}

 public void display() {
  fill(255);
  ellipse(starX, starY, 5, 5);
}
}
//game vars
int screenIndex = 0; //0 = game, 1 = title, 2 = level select, 3 = visual novel story stuff
int bulletCount = 500;
int basicECount = 20;
int starCount = 300;
int timing = 0;
int screenX = 1280;
int screenY = 720;

//player vars
int playerX = 200;
int playerY = 250;
int playerHitX = 60;
int playerHitY = 20;
int playerMoveX = 2;
int playerMoveY = 2;
int playerWeapon = 0;
int playerState = 0; //0 = normal, 1 = hurt
int bulletIndex = 0;
float playerShield = 20;
float playerShieldMax = 100;
float playerShieldRegen = 0.5f;
float playerHP = 50;
float playerHPMax = 100;

//input vars
boolean keyInput[] = new boolean [15];

//visual novel vars
int eventIndex = 0; //index value for events
int textIndex = 0; //index value for which line of dialogue should be displayed
int bgIndex = 0; //background index
int textTiming = 0; //used for rendering each letter individually, ie it looks like its being typed out
String[] textLines = new String[99]; //used for each line of dialogue
 public void drawVN() {
  strokeWeight(2);
  stroke(255);
  fill(20, 20, 255);
  rect(20, 450, 1240, 250, 20);
  rect(1150, 650, 100, 40, 5);
  rect(1040, 650, 100, 40, 5);
  textSize(48);
  fill(255);
  noStroke();
  text(textLines[textIndex], 35, 460, 1230, 250);
  textSize(32);
  text("SKIP", 1050, 680);
  text("NEXT", 1160, 680);
  
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "edge_of_solaris" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
