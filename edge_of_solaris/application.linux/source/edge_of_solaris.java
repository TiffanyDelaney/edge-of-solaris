/* autogenerated by Processing revision 1278 on 2022-03-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class edge_of_solaris extends PApplet {

bullet[] blts;
enemy[] basicE;
starsBG[] stars;
damage[] dmg;

PImage naturals1;
PImage naturals2;
PImage naturals3;
PImage naturals4;
PImage naturals5;
PImage player1;
PImage vnPlayer1;
PImage vnPlayer2;
PImage vnPlayer1r;
PImage vnPlayer2r;
PImage vnSol1;
PImage vnSol2;
PImage vnSol3;
PImage vnSol1r;
PImage vnSol2r;
PImage vnSol3r;
PImage vnEsence1;
PImage vnEsence2;
PImage vnEsence3;
PImage vnEsence4;
PImage vnEsence1r;
PImage vnEsence2r;
PImage vnEsence3r;
PImage vnEsence4r;
PImage vnVeda1;
PImage vnVeda2;
PImage vnVeda3;
PImage vnVeda4;
PImage vnVeda1r;
PImage vnVeda2r;
PImage vnVeda3r;
PImage vnVeda4r;
PImage vnCyana1;
PImage vnCyana2;
PImage vnCyana3;
PImage vnCyana4;
PImage settingsBtn;
PImage shadow;
PImage shadow2;
PImage shadow3;

PrintWriter settingsOut;
PrintWriter OSver;
JSONObject settingsJSON;



 public void setup(){
  /* size commented out by preprocessor */;
  frameRate(60);
  blts = new bullet[bulletCount];
  basicE = new enemy[basicECount];
  stars = new starsBG[starCount];
  dmg = new damage[dmgCount];
  initObjects(); //initializes all objects to "default" values
  loadText(); //load the text file for visual novel text
  loadSprites(); //load in png images for sprites
  loadSave(); //load the gamesave.sav file
  scanForStartPoints();
}

 public void draw() {
  processInput();
  drawFrame();
  drawUI();
  if (screenIndex == 3) {
    fill(0);
    rect(0, 0, 100, 50);
  }
  fill(200, 50, 50);
  textSize(24);
  text(frameRate, 20, 20);
  if (paused == false) {
    if (timing < 255) timing++;
    if (secondTiming < 255) secondTiming++;
  }
}

 public void drawFrame() {
  if (screenIndex == 0) {
    if (paused == false) {
     //render background
     if (levelType == 1) background(180, 248, 255);
     else if (levelType == 2) background(0);
      
    if (levelType == 2 || levelType == 1) {
      for (starsBG stars : stars) {
        stars.update();
        stars.display();
      }
    }
    
    for (enemy basicE : basicE) {
      basicE.update();
      basicE.collision();
      basicE.shoot();
      basicE.display();
    }
    for (bullet blts : blts) {
      blts.update();
      blts.display();
    }
    for (damage dmg : dmg) {
      dmg.update();
    }
    if (damageOnTop ==false) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    
    if (levelType == 0) { //over land
      
    } else if (levelType == 1) { //over water
      noStroke();
      fill(50, 50, 255);
      ellipse(640, 750, 2000, 200);
    } 
    levelEndCheckTimer++;
    if (levelEndCheckTimer > 60) { //check to see if all enemies are dead once a second
      levelEndCheckTimer = 0;
      for (int i = 0; i < basicECount; i++) {
        if (basicE[i].enemyState != 2) {
          break; //break out of loop for efficiency
        }else if (i == (basicECount - 1)) {
          levelEnd = true; //switch to level end screen
          keyInput[4] = false; //release space key
          paused = true; //put game in paused state
          break; //break out of loop for efficiency
        }
      }
    }
    
    //draw player
    playerCollision();
    if (playerShield < playerShieldMax) playerShield = playerShield + playerShieldRegen; //regen shield if depleted
    if (playerShield > playerShieldMax) playerShield = playerShieldMax; //ensure shield does not increase past max
    if (playerState == 0) setRect(1); //if player not being hurt
    else { //if player being hurt
      setRect(2); 
      playerState--;  //reset player state
      rect(playerX, playerY + 10, playerHitX, playerHitY - 10, 10); //render player hurt state
    }
    
    if (playerHP <= 0) { //if player dies
      paused = true; //pause game
      playerState = 255; //set player as dead
      playerAnimTiming = 30; //set timer for death anim
      keyInput[4] = false; //unset space key
    }
    
    //render the engine glow effect
    noStroke();
    fill(0, 127, 255, 100);
    ellipse(playerX - 6, playerY + 12.5f, 30 + abs(playerEngineTimer / 3), 10);
    fill(0, 165, 255, 120);
    ellipse(playerX - 3, playerY + 12.5f, 20 + abs(playerEngineTimer / 3), 10);
    fill(60, 240, 255, 150);
    ellipse(playerX - 1, playerY + 12.5f, 15 + abs(playerEngineTimer / 3), 8);
    fill(100, 240, 255, 200);
    ellipse(playerX - 1, playerY + 12.5f, 10 + abs(playerEngineTimer / 3), 6);
    playerEngineTimer++;
    if (playerEngineTimer == 15) playerEngineTimer = -15;
    
    image(player1, playerX - 5, playerY - 5); //player sprite
    
    if (damageOnTop == true) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    } else if (paused == true) { //if game is paused
           //render background
     if (levelType == 1) background(180, 248, 255);
     else if (levelType == 2) background(0);
      
    if (levelType == 2 || levelType == 1) {
      for (starsBG stars : stars) {
        stars.display();
      }
    }
    
    for (enemy basicE : basicE) {
      basicE.display();
    }
    for (bullet blts : blts) {
      blts.display();
    }
    if (damageOnTop == false) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    if (levelType == 0) { //over land
      
    } else if (levelType == 1) { //over water
      noStroke();
      fill(50, 50, 255);
      ellipse(640, 750, 2000, 200);
    }
    if (playerState == 255) { //if player dead
      if (playerAnimTiming != 0) {
        fill(255, 127, 0, 100);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 5), (playerHitY / 2) + (playerAnimTiming * 3));
        fill(255, 165, 0, 120);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 4), (playerHitY / 2) + (playerAnimTiming * 2));
        fill(255, 240, 60, 150);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 3), (playerHitY / 2) + (playerAnimTiming * 1));
        playerAnimTiming--;
      }
      textSize(60);
      fill(255, 50, 50);
      text("YOU DIED", 550, 350);
      textSize(48);
      text("Press R or Space to restart", 400, 450);
      
    } else {
      image(player1, playerX - 5, playerY - 5); //player sprite if player is not dead
      if (levelEnd == true) { //if on level end screen
      textSize(60);
      fill(255, 50, 50);
      text("Level Complete", 550, 350);
      textSize(48);
      text("Press Space to continue", 490, 450);
      if (keyInput[4] == true) levelEnd();
    } else { //if paused, player not dead and level not complete
      textSize(60);
      fill(255, 50, 50);
      text("PAUSED", 550, 350);
    }
    }
    if (damageOnTop == true) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    
    
    }
  } else if (screenIndex == 1) {
    resetObjects(); //reset objects on non game screens 
  } else if (screenIndex == 3) {
    drawVN();
  }
}

 public void drawUI() {
  if (screenIndex == 0) { //in game
    textSize(25);
    fill(255);
    //text("Q, E, R switch weapons", 50, 640);
    
    //render hp and shield bars
    if (oneHitMode == false) {
      stroke(0);
      strokeWeight(15);
      fill(0);
      rect(20, 650, 200, 50, 10);
      rect(235, 650, 200, 50, 10);
      setRect(4);
      if (playerHP >= 0) rect(23, 653.5f, (195 * (playerHP / playerHPMax)), 44);
      setRect(5);
      rect(238, 653.5f, (194 * (playerShield / playerShieldMax)), 44);
      setRect(3); //render surrounds
      noFill();
      rect(20, 650, 200, 50, 10);
      rect(235, 650, 200, 50, 10);
      fill(0);
    }
    
    //render weapon selector
    stroke(255);
    strokeWeight(2);
    rect(450, 653, 30, 20, 5);
    rect(450, 678, 30, 20, 5);
    rect(485, 653, 30, 20, 5);
    rect(485, 678, 30, 20, 5);
  } else if (screenIndex == 1) { //title page
    background(0);
    fill(200, 200, 255, 120);
    textSize(130);
    text("Edge Of Solaris", 240, 120);
    text("Edge Of Solaris", 248, 120);
    fill(200, 200, 255, 255);
    textSize(128);
    text("Edge Of Solaris", 250, 120);
    fill(200, 200, 255);
    textSize(90);
    text("random tagline in space", 200, 240);
    textSize(64);
    text("new game", 500, 400);
    text("continue", 500, 500);
    text("press space to continue (temp)", 50, 650);
    textSize(24);
    text("build " + buildNumber, 1175, 700);
  } else if (screenIndex == 2) { //level select
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(950, 125, 300, 75);
    rect(950, 225, 300, 75);
    rect(950, 325, 300, 75);
    //draw level select rects
    rect(50, 25, 400, 75);
    rect(50, 125, 400, 75);
    rect(50, 225, 400, 75);
    rect(50, 325, 400, 75);
    //draw options button
    image(settingsBtn, 1000, 450, 200, 200);
    noStroke();
    fill(255);
    textSize(48);
    text("status", 975, 75);
    text("mess hall", 975, 175);
    text("hanger", 975, 275);
    text("engineering", 975, 375);
    text("launch story", 75, 75);
    text("level 00", 75, 175);
    text("level 01", 75, 275);
    text("test level", 75, 375);
  } else if (screenIndex == 4) { //settings menu
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(50, 25, 400, 75);
    if (oneHitMode == true) {
      fill(0, 150, 0);
    }
    rect(475, 25, 75, 75);
    fill(50, 0, 50); // reset color
    if (damageOnTop == true) {
      fill(0, 150, 0);
    }
    rect(475, 125, 75, 75);
    fill(50, 0, 50); // reset color
    rect(50, 125, 400, 75);
    rect(50, 225, 400, 75);
    //draw options button
    noStroke();
    fill(255);
    textSize(48);
    text("Back", 975, 75);
    text("one hit mode", 75, 75);
    text("damage on top", 75, 175);
    text("shadow", 75, 275);
  } else if (screenIndex == 5) { //status window
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(50, 25, 400, 75);
    rect(50, 125, 400, 75);
    rect(50, 225, 400, 75);
    rect(50, 325, 400, 75);
    rect(50, 425, 400, 75);
    
    rect(475, 25, 125, 75);
    rect(475, 125, 125, 75);
    rect(475, 225, 125, 75);
    rect(475, 325, 125, 75);
    rect(475, 425, 125, 75);
    
    rect(625, 125, 75, 75);
    rect(625, 225, 75, 75);
    rect(625, 325, 75, 75);
    rect(625, 425, 75, 75);
    //draw options button
    noStroke();
    fill(255);
    textSize(48);
    text("Back", 975, 75);
    text("total stat points", 75, 75);
    text("hp", 75, 175);
    text("shield", 75, 275);
    text("defense", 75, 375);
    text("attack", 75, 475);
    
    text("+", 650, 175);
    text("+", 650, 275);
    text("+", 650, 375);
    text("+", 650, 475);
    
    text(playerStatPoints, 490, 75);
    text((int)playerHPMax, 490, 175);
    text((int)playerShieldMax, 490, 275);
    text((int)(playerDefense * 100), 490, 375);
    text((int)(playerAttack * 100), 490, 475);
  }
}

 public void levelEnd() { //called when the level should end
  keyInput[4] = false; //release space key
  levelEnd = false; //turn off level end trigger
  paused = false; //unpause game
  screenIndex = 3;
  textIndex = scriptStartPoints[levelIndex+1];
  /*
  if (levelIndex == 0) {
    screenIndex = 3; //set to vn section
    textIndex = 11; //set text index to next vn section
  } else if (levelIndex == 1) {
    screenIndex = 3;
    textIndex = 16;
  }*/
}

 public void levelStart(int cmdIndex) {
  levelIndex = cmdIndex;
  screenIndex = 0;
  playerX = 200;
  playerY = 250;
  playerHP = playerHPMax;
  playerShield = playerShieldMax;
  playerState = 0;
  initObjects();
  placeEnemies();
  
  //calculate stats
  if (oneHitMode == true) enemyBalanceDMG = 9000;
  playerDMGReduction = 1 - ((playerDefense - 1) * 0.1f);
  if (playerDMGReduction <= 0.30f) playerDMGReduction = 0.30f;
  playerShieldRegen = (playerShieldMax / 100) * playerShieldRegenBoost;
}

 public void setRect(int colorIndex) {
  if (colorIndex == 0) {
    strokeWeight(1);
    noStroke();
    fill(0);
  } else if (colorIndex == 1) { //used for player ship rendering
    strokeWeight(1);
    noStroke();
    fill(255);
  } else if (colorIndex == 2) { //used for player hurt rendering
    strokeWeight(10);
    stroke(200, 0, 0, 100);
    fill(255, 200, 200);
  } else if (colorIndex == 3) { //used for hp surround
    strokeWeight(6);
    fill(0);
    stroke(255);
  } else if (colorIndex == 4) { //used for hp bar fill
    noStroke();
    fill(20, 255, 20);
  } else if (colorIndex == 5) {
    noStroke();
    fill(20, 20, 255);
  }
}

 public void initObjects() { //set all objects to default (meant to be run in setup)
  for (int i = 0; i < bulletCount; i++) {
    blts[i] = new bullet(-20, -20, 0, 0, 255, 0, 0, 0);
  }
  for (int i = 0; i < basicECount; i++) {
    basicE[i] = new enemy(-200, -200, 0, 0, 255, 0, 0, 10, 10, 0, 2, 0);
  }
  for (int i = 0; i < starCount; i++) {
    stars[i] = new starsBG(PApplet.parseInt(random(screenX + 20)), PApplet.parseInt(random(screenY)), PApplet.parseInt(-1 * (random(10) + 1)), 0);
  }
  for (int i = 0; i < dmgCount; i++) {
    dmg[i] = new damage(-200, -200, 0, 0, 0);
  }
}

 public void resetObjects() { //resets objects (similar to init but meant to be run in main loop)
    for (starsBG stars : stars) {
      stars.reset();
    }
    for (enemy basicE : basicE) {
      basicE.reset();
    }
    for (bullet blts : blts) {
      blts.reset();
    }
    for (damage dmg : dmg) {
      dmg.reset();
    }
}

 public void playerCollision() { //check collision with enemy bullets/ships
    for (int i = 0; i < bulletCount; i++) {
   if (blts[i].bulletType == 200 || blts[i].bulletType == 201) { //check to ensure bullet is an enemy bullet
    if (playerX <= blts[i].bulletX + (blts[i].bulletHitX / 2)) {
      //println(( enemyX + (enemyHitX / 2)) + " + " + (blts[i].bulletX +  (blts[i].bulletHitX / 2)));
      if ((playerX + (playerHitX / 1)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (playerY + 10 <= blts[i].bulletY + (blts[i].bulletHitY / 2)) {
          if ((playerY + (playerHitY / 1)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
              playerState = 10;
              playerShield = playerShield - (blts[i].bulletPower * playerDMGReduction);
              dmg[findDamage()] = new damage(playerX - 10, playerY - 20, (blts[i].bulletPower * playerDMGReduction), 1, 30);
              if (playerShield < 0) { //if shield goes negative
                playerHP = playerHP - abs(playerShield); //subtract the difference of how negative the shield is
                playerShield = 0; //make sure player shield does not go negative
              }
            
            if (blts[i].bulletType == 200) blts[i].reset();
          }
        }
      }
    }
  }
  }
  for (int i = 0; i < basicECount; i++) { //check collision with enemy planes
   if (basicE[i].enemyState != 2) { //check to ensure ship is not dead
    if (playerX <= basicE[i].enemyX + (basicE[i].enemyHitX / 2)) {
      if ((playerX + (playerHitX / 1)) >= (basicE[i].enemyX - (basicE[i].enemyHitX / 2))) {
        if (playerY + 10 <= basicE[i].enemyY + (basicE[i].enemyHitY / 2)) {
          if ((playerY + (playerHitY / 1)) >= (basicE[i].enemyY - (basicE[i].enemyHitY / 2))) {
              playerState = 10;
              playerShield = playerShield - (basicE[i].enemyHP * enemyBalanceBump * enemyBalanceDMG * playerDMGReduction);
              dmg[findDamage()] = new damage(playerX - 10, playerY - 20, (basicE[i].enemyHP * enemyBalanceBump * enemyBalanceDMG * playerDMGReduction), 1, 30);
              if (playerShield < 0) { //if shield goes negative
                playerHP = playerHP - abs(playerShield); //subtract the difference of how negative the shield is
                playerShield = 0; //make sure player shield does not go negative
              }
            //kill enemy
            basicE[i].enemyHP = 0;
            basicE[i].enemyState = 2;
            basicE[i].enemyTiming = 30;
          }
        }
      }
    }
  }
  }
}

 public int findBullet () { //finds next unused bullet and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (blts[i].bulletType == 255) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (bulletCount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}

 public int findEnemy () { //finds next unused enemy and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (basicE[i].enemyState == 2) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (basicECount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}

 public int findDamage () { //finds next unused enemy and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (dmg[i].damageTimer == 0) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (dmgCount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}
class bullet {
  float bulletX; //bullet x pos
  float bulletY; //bullet y pos
  float bulletSpeedX; //bullet x speed
  float bulletSpeedY; //bullet y speed
  int bulletType; //255 = dead/inactive bullet, 0-199 = player bullets, 200-254 = enemy bullets
  int bulletHitX; //bullet hitbox x
  int bulletHitY; //bullet hitbox y
  float bulletPower; //bullet impact damage (defined on bullet gen)

bullet(float bulletXtemp, float bulletYtemp, float bulletSpeedXtemp, float bulletSpeedYtemp, int bulletTypetemp, int bulletHitXtemp, int bulletHitYtemp, float bulletPowertemp) {
  bulletX = bulletXtemp;
  bulletY = bulletYtemp;
  bulletSpeedX = bulletSpeedXtemp;
  bulletSpeedY = bulletSpeedYtemp;
  bulletType = bulletTypetemp;
  bulletHitX = bulletHitXtemp;
  bulletHitY = bulletHitYtemp;
  bulletPower = bulletPowertemp;
}

 public void update() {
  if (bulletX > (screenX + 100) || bulletX < -100 || bulletY > (screenY + 100) || bulletY < -100) bulletType = 255; //destroy bullet if off screen
  else { //if bullet is not off screen, update bullet position
    bulletX = bulletX + bulletSpeedX; //update bullet x according to x speed
    bulletY = bulletY + bulletSpeedY; //update bullet y according to y speed
  }
  if (bulletType == 100) {
    if (bulletSpeedY > 0) bulletSpeedY--;
    if (bulletSpeedY < 0) bulletSpeedY++;
    if (bulletSpeedX < 5) bulletSpeedX++;
  }
}

public void reset() {
  bulletX = -20;
  bulletY = -20;
  bulletSpeedX = 0;
  bulletSpeedY = 0;
  bulletType = 255;
  bulletHitX = 0;
  bulletHitY = 0;
  bulletPower = 0;
}

 public void explode() {
}

 public void display() {
  if (bulletType == 0) { //machine gun
    stroke(20, 20, 200, 120);
    strokeWeight(2);
    fill(20, 20, 200);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 1) { //spread shot
    noStroke();
    fill(20, 20, 255, 200);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    stroke(255, 120);
    strokeWeight(2);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 4) { //snipe shot
    noStroke();
    fill(20, 20, 255, 200);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    stroke(255, 120);
    strokeWeight(10);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 100) { //basic secondary missile
    stroke(255, 20, 20, 200);
    strokeWeight(3);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 2) { //dual beam cannon
    stroke(20, 20, 200, 150);
    strokeWeight(2);
    fill(100, 100, 255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 200) { //basic enemy shot
    stroke(20, 200, 20, 150);
    strokeWeight(2);
    fill(20, 255, 20, 150);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    fill(175, 255, 175);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }
}
}
class damage {
  float damageX;
  float damageY;
  float damage;
  int damageType;
  int damageTimer;
  
  damage(float damageXtemp, float damageYtemp, float damagetemp, int damageTypetemp, int damageTimertemp) {
    damageX = damageXtemp;
    damageY = damageYtemp;
    damage = damagetemp;
    damageType = damageTypetemp;
    damageTimer = damageTimertemp;
  }
  
   public void update() {
    if (damageTimer != 0) {
      damageTimer--;
      damageY--;
    }
  }
  
   public void display() {
    if (damageTimer != 0) {
      if (damageType == 0) {
        int fade = damageTimer * 8;
        if (fade > 255) fade = 255;
        noStroke();
        textSize(24);
        fill(255, 20, 20, fade);
        text(damage, damageX, damageY);
      } else if (damageType == 1) {
        int fade = damageTimer * 8;
        if (fade > 255) fade = 255;
        noStroke();
        textSize(24);
        fill(200, 20, 255, fade);
        text(damage, damageX, damageY);
      }
    }
  }
  
   public void reset() {
    damageX = -200;
    damageY = -200;
    damage = 0;
    damageType = 0;
    damageTimer = 0;
  }
}
class enemy {
  float enemyX; //enemy x pos
  float enemyY; //enemy y pos
  float enemySpeedX; //enemy x speed
  float enemySpeedY; //enemy y speed
  int enemyType; //type of enemy, 0 = basic, 1 = big, 2 = modema ship
  float enemyHitX; //enemy hitbox x
  float enemyHitY; //enemy hitbox y
  float enemyHP; //enemy current hp
  float enemyHPMax; //enemy max hp
  int enemyTiming; //enemy timing, used for projectile shot timing
  int enemyState; //0 = normal, 1 = hurt, 2 = dead
  float enemyMoveTiming; //used to move enemies in various ways

enemy(int enemyXtemp, int enemyYtemp, int enemySpeedXtemp, int enemySpeedYtemp, int enemyTypetemp, int enemyHitXtemp, int enemyHitYtemp, float enemyHPtemp, float enemyHPMaxtemp, int enemyTimingtemp, int enemyStatetemp, int enemyMoveTimingtemp) {
  enemyX = enemyXtemp;
  enemyY = enemyYtemp;
  enemySpeedX = enemySpeedXtemp;
  enemySpeedY = enemySpeedYtemp;
  enemyType = enemyTypetemp;
  enemyHitX = enemyHitXtemp;
  enemyHitY = enemyHitYtemp;
  enemyHP = enemyHPtemp;
  enemyHPMax = enemyHPMaxtemp;
  enemyTiming = enemyTimingtemp;
  enemyState = enemyStatetemp;
  enemyMoveTiming = enemyMoveTimingtemp;
}

 public void update() {
  enemyX = enemyX + enemySpeedX; //update enemy x pos according to speed
  enemyY = enemyY + enemySpeedY; //update enemy y pos according to speed
  if (enemyHP <= 0) enemyState = 2; //set enemy as dead if hp is zero
  if (enemyState != 2) { //only run if enemy is not dead
    if (enemyTiming < 255) enemyTiming++; //increment enemy timer (used for timing enemy firing
    
    switch(enemyType) {
      case 0:
      enemySpeedY = (sin((enemyMoveTiming / 1)) * 1);
      enemyMoveTiming = enemyMoveTiming + 0.025f;
      break;
      case 4:
      if (enemyX <= 1000) enemyX = 1000;
      else enemyTiming = 199;
      break;
      default:
      break;
    }
    
    if (enemyX < -200) enemyState = 2; //kill enemy if off screen
  }
}

 public void collision() {
  for (int i = 0; i < bulletCount; i++) { //run for every bullet instance
   if (blts[i].bulletType != 255 && enemyState != 2) { //check to ensure bullet is not inactive (for efficiency) and enemy is not dead
    if (enemyX - (enemyHitX / 2) <= blts[i].bulletX - (blts[i].bulletHitX / 2)) {
      //println(( enemyX + (enemyHitX / 2)) + " + " + (blts[i].bulletX +  (blts[i].bulletHitX / 2)));
      if ((enemyX + (enemyHitX / 2)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (enemyY - (enemyHitY / 2) <= blts[i].bulletY - (blts[i].bulletHitY / 2)) {
          if ((enemyY + (enemyHitY / 2)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
            if (blts[i].bulletType < 199) { //check if bullet type is player projectile
              enemyState = 1; //change enemy to hurt state
              enemyHP = enemyHP - blts[i].bulletPower; //reduce enemy hp per bullet power
              dmg[findDamage()] = new damage(enemyX, enemyY, blts[i].bulletPower, 0, 30);
              if (enemyHP <= 0) {
                enemyTiming = 30; //start timer over for death anim
                enemyState = 2; //set enemy to dead
              }
              if (blts[i].bulletType != 4) blts[i].reset(); //reset bullet on impact if not snipe shot
            }
            
          }
        }
      }
    }
  }
  }
}

 public void reset() {
  enemyX = -250;
  enemyY = -250;
  enemySpeedX = 0;
  enemySpeedY = 0;
  enemyType = 255;
  enemyHitX = 0;
  enemyHitY = 0;
  enemyHP = 0;
  enemyHPMax = 0;
  enemyState = 2; //dead
}

 public void hit(int bulletType) {
  //TEMP
}

 public void shoot() {
   if (enemyState != 2 && enemyX < 1250) {
    if (enemyType == 0) { //check to see if enemy is basic and not dead
    if (enemyTiming > 60) { //check to make sure enough time has passed since last shot
    float speed = 10; //higher numbers are slower
    int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
    int offsetY = 10; //account for incorrect aim
    float c = sqrt((abs(playerX - enemyX + offsetX)) + abs((playerY - enemyY + offsetY))); //solve for hypotenuse
    c = c * speed; //scale c (distance hypotenuse) to speed
    float speedX = (playerX - enemyX + offsetX);
    float speedY = (playerY - enemyY + offsetY);
    speedX = speedX / (c);
    speedY = speedY / (c);
    blts[findBullet()] = new bullet(enemyX, enemyY, speedX, speedY, 200, 10, 10, 10 * enemyBalanceDMG);
    enemyTiming = 0;
    }
  } else if (enemyType == 1) { //check for enemy type
    if (enemyTiming > 80) { //check to make sure enough time has passed since last shot
    blts[findBullet()] = new bullet(enemyX - 50, enemyY + 13, -5, 0, 200, 50, 5, 10 * enemyBalanceDMG);
    enemyTiming = 0;
    }
  } else if (enemyType == 2) { //check for enemy type
    if (enemyTiming > 120) { //check to make sure enough time has passed since last shot
    blts[findBullet()] = new bullet(enemyX, enemyY, -5, +2, 200, 10, 10, 10 * enemyBalanceDMG);
    blts[findBullet()] = new bullet(enemyX, enemyY, -5, +1, 200, 10, 10, 10 * enemyBalanceDMG);
    blts[findBullet()] = new bullet(enemyX, enemyY, -5, 0, 200, 10, 10, 10 * enemyBalanceDMG);
    blts[findBullet()] = new bullet(enemyX, enemyY, -5, -1, 200, 10, 10, 10 * enemyBalanceDMG);
    blts[findBullet()] = new bullet(enemyX, enemyY, -5, -2, 200, 10, 10, 10 * enemyBalanceDMG);
    enemyTiming = 0;
    }
    } else if (enemyType == 3) { //check for enemy type
    if (enemyTiming > 30) { //check to make sure enough time has passed since last shot
      blts[findBullet()] = new bullet(enemyX - 40, enemyY + 13, -10, 0, 200, 10, 5, 5 * enemyBalanceDMG);
      enemyTiming = 0;
    }
  } else if (enemyType == 4) { //check for enemy type
    if (enemyTiming > 200) { //check to make sure enough time has passed since last shot
    basicE[findEnemy()] = new enemy(PApplet.parseInt(enemyX - 80), PApplet.parseInt(enemyY + 15), -2, 0, 5, 50, 50, 50, 50, 0, 0, 0); //i have no idea why the x/y need to be cast as ints but they do
    basicE[findEnemy()] = new enemy(PApplet.parseInt(enemyX - 80), PApplet.parseInt(enemyY + 15), -2, -1, 5, 50, 50, 50, 50, 0, 0, 0);
    basicE[findEnemy()] = new enemy(PApplet.parseInt(enemyX - 80), PApplet.parseInt(enemyY + 15), -2, 1, 5, 50, 50, 50, 50, 0, 0, 0);
      enemyTiming = 0;
    }
  } else if (enemyType == 5) { //check for enemy type, this is the bomb
    if (enemyTiming > 120) { //check to make sure enough time has passed since last shot
      blts[findBullet()] = new bullet(enemyX, enemyY, 0, -4, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, 0, +4, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, +4, 0, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -4, 0, 200, 10, 10, 10 * enemyBalanceDMG);
      
      blts[findBullet()] = new bullet(enemyX, enemyY, -2.828f, +2.828f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -2.828f, -2.828f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, +2.828f, +2.828f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, +2.828f, -2.828f, 200, 10, 10, 10 * enemyBalanceDMG);
      
      blts[findBullet()] = new bullet(enemyX, enemyY, +1.53f, +3.695f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -1.53f, +3.695f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, +1.53f, -3.695f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -1.53f, -3.695f, 200, 10, 10, 10 * enemyBalanceDMG);
      
      blts[findBullet()] = new bullet(enemyX, enemyY, +3.695f, +1.53f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -3.695f, +1.53f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, +3.695f, -1.53f, 200, 10, 10, 10 * enemyBalanceDMG);
      blts[findBullet()] = new bullet(enemyX, enemyY, -3.695f, -1.53f, 200, 10, 10, 10 * enemyBalanceDMG);
      
      //destroy bomb
      enemyTiming = 30;
      enemyState = 2;
      enemyHP = 0;
    }
  } else if (enemyType == 6) {
    if (enemyTiming > 20 && enemyX < 200) {
      float speed = 10; //higher numbers are slower
      int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
      int offsetY = 10; //account for incorrect aim
      float c = sqrt((abs(playerX - enemyX + offsetX)) + abs((playerY - enemyY + offsetY))); //solve for hypotenuse
      c = c * speed; //scale c (distance hypotenuse) to speed
      float speedX = (playerX - enemyX + offsetX);
      float speedY = (playerY - enemyY + offsetY);
      speedX = speedX / (c);
      speedY = speedY / (c);
      blts[findBullet()] = new bullet(enemyX, enemyY, speedX, speedY, 200, 10, 10, 10 * enemyBalanceDMG);
      enemyTiming = 0;
    }
  }
   }
}

 public void display() {
  strokeWeight(1);
  noStroke();
  if (enemyState == 1) tint(255, 100, 100);
  if (enemyState != 2) { //do not display hp bar if enemy is dead
    strokeWeight(1);
    stroke(0);
    fill(20, 255, 20, 100);
    rect(enemyX - (enemyHitX * 0.45f), enemyY - (enemyHitY - 5), ((enemyHitX - 5) * (enemyHP / enemyHPMax)), 5);
    
      switch (enemyType) {
        case 0: //drone that fires a homing shot
        image(naturals1, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 1: //small gunship
        image(naturals2, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 2: //small interceptor (spread shot)
        image(naturals3, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 3: //medium interceptor
        image(naturals4, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 4: //cargo ship
        image(naturals5, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 6: //small interceptor that does not fire until it reaches a certain part of the screen, then fires a homing shot
        image(naturals3, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        default:
        noStroke();
        fill(255, 0, 0);
        ellipse(enemyX, enemyY, enemyHitX, enemyHitY);
        break;
      }
    tint(255, 255, 255); //reset tint
    enemyState = 0; //reset enemy state (so it untints after being shot)
  } else if (enemyState == 2 && enemyTiming !=0) { //death state anim
    fill(255, 127, 0, 100);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 5), (enemyHitY / 2) + (enemyTiming * 3));
    fill(255, 165, 0, 120);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 4), (enemyHitY / 2) + (enemyTiming * 2));
    fill(255, 240, 60, 150);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 3), (enemyHitY / 2) + (enemyTiming * 1));
    enemyTiming--;
  }
  
}
}
 public void loadText() {
  String[] loadScript = loadStrings("assets/text/script.txt");
  file = new File(userDataDir(), "settings.json");
  if (file.isFile() == true) {settingsJSON = loadJSONObject(file); useCWD = true;} else settingsJSON = loadJSONObject("settings.json");
  
  int tempInt = settingsJSON.getInt("oneHitMode");
  if (tempInt == 1) oneHitMode = true; else oneHitMode = false;
  tempInt = settingsJSON.getInt("damageOnTop");
  if (tempInt == 1) damageOnTop = true; else damageOnTop = false;
  
  for(int i = 0; i < loadScript.length; i++) {
    textLines[i] = loadScript[i]; //this is necessary trust me
    scriptLength++;
  }
}

 public String userDataDir() {
  // Default to CWD, allow overriding with '-Dsolaris.dir'
  return System.getProperty("solaris.dir", System.getProperty("user.dir"));
}

 public String[] loadUserDataFile(String name) {
  // Load file in the user data directory, falling back to the one in the sketch
  // directory if it does not exist yet
  final File file = new File(userDataDir(), name);
  return file.isFile() ? loadStrings(file) : loadStrings("gamesave.save");
}

 public void loadSave() {
  String[] loadSave = loadUserDataFile("gamesave.save");

  char[] saveChar = loadSave[0].toCharArray();
  playerHPMax = (saveChar[13] - '0') * 1000 + (saveChar[14] - '0') * 100 +
                (saveChar[15] - '0') * 10 + (saveChar[16] - '0');

  saveChar = loadSave[1].toCharArray();
  playerShieldMax = (saveChar[17] - '0') * 1000 + (saveChar[18] - '0') * 100 +
                    (saveChar[19] - '0') * 10 + (saveChar[20] - '0');

  saveChar = loadSave[2].toCharArray();
  playerDefense = ((saveChar[15] - '0') * 1000 + (saveChar[16] - '0') * 100 +
                   (saveChar[17] - '0') * 10 + (saveChar[18] - '0'));
  playerDefense = playerDefense * 0.01f;

  saveChar = loadSave[3].toCharArray();
  playerAttack = ((saveChar[14] - '0') * 1000 + (saveChar[15] - '0') * 100 +
                  (saveChar[16] - '0') * 10 + (saveChar[17] - '0'));
  playerAttack = playerAttack * 0.01f;
}

 public void saveSettings() {
  if (oneHitMode == true) settingsJSON.setInt("oneHitMode", 1); else settingsJSON.setInt("oneHitMode", 0);
  if (damageOnTop == true) settingsJSON.setInt("damageOnTop", 1); else settingsJSON.setInt("damageOnTop", 0);
  
  saveJSONObject(settingsJSON, "settings.json");
  /*
  settingsOut = createWriter(new File(userDataDir(), "config.ini"));
  int tempOut;
  if (oneHitMode == true)
    tempOut = 1;
  else
    tempOut = 0;
  settingsOut.println("OneHitMode: " + tempOut);
  if (damageOnTop == true)
    tempOut = 1;
  else
    tempOut = 0;
  settingsOut.println("DamageOnTop: " + tempOut);
  settingsOut.flush();
  settingsOut.close(); */
}

 public void loadSprites() {
  naturals1 = loadImage("assets/png/naturals/3-xx.png");
  naturals2 = loadImage("assets/png/naturals/2-xx.png");
  naturals3 = loadImage("assets/png/naturals/1-xx.png");
  naturals4 = loadImage("assets/png/naturals/4-xx.png");
  naturals5 = loadImage("assets/png/naturals/5-xx.png");
  player1 = loadImage("assets/png/player/3-x.png");

  vnPlayer1 = loadImage("assets/vn/player/1.png");
  vnPlayer2 = loadImage("assets/vn/player/2.png");
  vnPlayer1r = loadImage("assets/vn/player/1-r.png");
  vnPlayer2r = loadImage("assets/vn/player/2-r.png");
  vnSol1 = loadImage("assets/vn/sol/1.png");
  vnSol2 = loadImage("assets/vn/sol/2.png");
  vnSol3 = loadImage("assets/vn/sol/3.png");

  vnEsence1 = loadImage("assets/vn/esence/1.png");
  vnEsence2 = loadImage("assets/vn/esence/2.png");
  vnEsence3 = loadImage("assets/vn/esence/3.png");
  vnEsence4 = loadImage("assets/vn/esence/4.png");

  vnCyana1 = loadImage("assets/vn/cyana/1.png");
  vnCyana2 = loadImage("assets/vn/cyana/2.png");
  vnCyana3 = loadImage("assets/vn/cyana/3.png");
  vnCyana4 = loadImage("assets/vn/cyana/4.png");

  settingsBtn = loadImage("assets/ui/settings.png");
  shadow = loadImage("assets/ui/shadow.png");
  shadow2 = loadImage("assets/ui/shadow2.png");
  shadow3 = loadImage("assets/ui/shadow3.gif");
}
 public void placeEnemies() {
  if (levelIndex == 2) {
    //temp layout
    genEnemy(0, 1000, 300);
    
    genEnemy(0, 1200, 200);
    genEnemy(0, 1200, 400);
    genEnemy(0, 1200, 100);
    genEnemy(0, 1200, 500);
    genEnemy(0, 1200, 600);
    genEnemy(0, 1200, 0);
    
    genEnemy(3, 1300, 50);
    genEnemy(3, 1300, 225);
    genEnemy(3, 1300, 400);
    genEnemy(3, 1300, 575);
    
    genEnemy(0, 1400, 100);
    genEnemy(0, 1400, 300);
    genEnemy(0, 1400, 500);
    
    genEnemy(1, 1600, 50);
    genEnemy(1, 1600, 225);
    genEnemy(1, 1600, 400);
    genEnemy(1, 1600, 575);
    
    genEnemy(0, 1800, 100);
    genEnemy(0, 1800, 300);
    genEnemy(0, 1800, 500);
    
    genEnemy(3, 2000, 50);
    genEnemy(3, 2000, 225);
    genEnemy(3, 2000, 400);
    genEnemy(3, 2000, 575);
    
    genEnemy(1, 2200, 100);
    genEnemy(2, 2200, 300);
    genEnemy(1, 2200, 500);
    
    genEnemy(0, 2400, 50);
    genEnemy(0, 2400, 225);
    genEnemy(0, 2400, 400);
    genEnemy(0, 2400, 575);
    
    genEnemy(4, 3000, 50);
    genEnemy(4, 3000, 150);
    genEnemy(4, 3000, 250);
    genEnemy(4, 3000, 350);
    genEnemy(4, 3000, 450);
    genEnemy(4, 3000, 550);
    
    genEnemy(0, 3600, 0);
    genEnemy(0, 3600, 100);
    genEnemy(0, 3600, 200);
    genEnemy(0, 3600, 300);
    genEnemy(0, 3600, 400);
    genEnemy(0, 3600, 500);
    genEnemy(0, 3600, 600);
    
    genEnemy(0, 3700, 0);
    genEnemy(0, 3700, 100);
    genEnemy(0, 3700, 200);
    genEnemy(0, 3700, 300);
    genEnemy(0, 3700, 400);
    genEnemy(0, 3700, 500);
    genEnemy(0, 3700, 600);
    
    genEnemy(0, 3800, 0);
    genEnemy(0, 3800, 100);
    genEnemy(0, 3800, 200);
    genEnemy(0, 3800, 300);
    genEnemy(0, 3800, 400);
    genEnemy(0, 3800, 500);
    genEnemy(0, 3800, 600);
    
    genEnemy(0, 3900, 0);
    genEnemy(0, 3900, 100);
    genEnemy(0, 3900, 200);
    genEnemy(0, 3900, 300);
    genEnemy(0, 3900, 400);
    genEnemy(0, 3900, 500);
    genEnemy(0, 3900, 600);
    
    genEnemy(0, 4000, 0);
    genEnemy(0, 4000, 100);
    genEnemy(0, 4000, 200);
    genEnemy(0, 4000, 300);
    genEnemy(0, 4000, 400);
    genEnemy(0, 4000, 500);
    genEnemy(0, 4000, 600);
    
    genEnemy(0, 4100, 0);
    genEnemy(0, 4100, 100);
    genEnemy(0, 4100, 200);
    genEnemy(0, 4100, 300);
    genEnemy(0, 4100, 400);
    genEnemy(0, 4100, 500);
    genEnemy(0, 4100, 600);
    
    genEnemy(0, 4200, 0);
    genEnemy(0, 4200, 100);
    genEnemy(0, 4200, 200);
    genEnemy(0, 4200, 300);
    genEnemy(0, 4200, 400);
    genEnemy(0, 4200, 500);
    genEnemy(0, 4200, 600);
    
    genEnemy(0, 4300, 0);
    genEnemy(0, 4300, 100);
    genEnemy(0, 4300, 200);
    genEnemy(0, 4300, 300);
    genEnemy(0, 4300, 400);
    genEnemy(0, 4300, 500);
    genEnemy(0, 4300, 600);
    
    genEnemy(0, 4400, 0);
    genEnemy(0, 4400, 100);
    genEnemy(0, 4400, 200);
    genEnemy(0, 4400, 300);
    genEnemy(0, 4400, 400);
    genEnemy(0, 4400, 500);
    genEnemy(0, 4400, 600);
    
    genEnemy(0, 4500, 0);
    genEnemy(0, 4500, 100);
    genEnemy(0, 4500, 200);
    genEnemy(0, 4500, 300);
    genEnemy(0, 4500, 400);
    genEnemy(0, 4500, 500);
    genEnemy(0, 4500, 600);
    
    genEnemy(0, 4600, 0);
    genEnemy(0, 4600, 100);
    genEnemy(0, 4600, 200);
    genEnemy(0, 4600, 300);
    genEnemy(0, 4600, 400);
    genEnemy(0, 4600, 500);
    genEnemy(0, 4600, 600);
    
    genEnemy(0, 4700, 0);
    genEnemy(0, 4700, 100);
    genEnemy(0, 4700, 200);
    genEnemy(0, 4700, 300);
    genEnemy(0, 4700, 400);
    genEnemy(0, 4700, 500);
    genEnemy(0, 4700, 600);
    
    genEnemy(0, 4800, 0);
    genEnemy(0, 4800, 100);
    genEnemy(0, 4800, 200);
    genEnemy(0, 4800, 300);
    genEnemy(0, 4800, 400);
    genEnemy(0, 4800, 500);
    genEnemy(0, 4800, 600);
  } else if (levelIndex == 1) {
    genEnemy(6, 1000, 350);
    genEnemy(6, 800, 150);
    genEnemy(6, 800, 550);
    
    genEnemy(0, 1400, 350);
    genEnemy(0, 1400, 500);
    genEnemy(0, 1400, 200);
    
    genEnemy(3, 1700, 350);
    genEnemy(3, 1750, 400);
    genEnemy(3, 1750, 300);
    genEnemy(3, 1800, 450);
    genEnemy(3, 1800, 250);
    
    genEnemy(6, 2000, 450);
    genEnemy(6, 2050, 500);
    genEnemy(6, 2100, 550);
    
    genEnemy(6, 2200, 250);
    genEnemy(6, 2250, 200);
    genEnemy(6, 2300, 150);
    
    genEnemy(4, 2500, 300);
  } else if (levelIndex == 0) {
    genEnemy(6, 1000, 400);
    genEnemy(6, 1100, 500);
    genEnemy(6, 1200, 600);
    genEnemy(6, 1500, 300);
    genEnemy(6, 1600, 200);
    genEnemy(6, 1700, 100);
    
    genEnemy(6, 2100, 350);
    genEnemy(6, 2200, 450);
    genEnemy(6, 2200, 250);
    genEnemy(6, 2300, 550);
    genEnemy(6, 2300, 150);
    
    genEnemy(6, 2800, 350);
    genEnemy(6, 2850, 400);
    genEnemy(6, 2850, 300);
    genEnemy(6, 2900, 450);
    genEnemy(6, 2900, 250);
    genEnemy(6, 2950, 500);
    genEnemy(6, 2950, 200);
    genEnemy(6, 3000, 550);
    genEnemy(6, 3000, 150);
    
    genEnemy(6, 3200, 350);
    genEnemy(6, 3300, 450);
    genEnemy(6, 3300, 250);
    genEnemy(6, 3400, 550);
    genEnemy(6, 3400, 150);
    
    genEnemy(6, 3600, 350);
    genEnemy(6, 3650, 400);
    genEnemy(6, 3650, 300);
    genEnemy(6, 3700, 450);
    genEnemy(6, 3700, 250);
    genEnemy(6, 3750, 500);
    genEnemy(6, 3750, 200);
    genEnemy(6, 3800, 550);
    genEnemy(6, 3800, 150);
    
    //genEnemy(999, 4000, -500); //level complete enemy
  }
}

 public void genEnemy(int type, int x, int y) { //used for placing enemies easier, pass in enemy type and position x/y
  enemyIndex = findEnemy();
  basicE[enemyIndex].enemyState = 0;
  if (type == 0) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = 0;
    basicE[enemyIndex].enemyHitX = 110;
    basicE[enemyIndex].enemyHitY = 110;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 1) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 210;
    basicE[enemyIndex].enemyHitY = 86;
    basicE[enemyIndex].enemyHP = 30 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 30 * enemyBalanceHP;
  } else if (type == 2) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 170;
    basicE[enemyIndex].enemyHitY = 70;
    basicE[enemyIndex].enemyHP = 40 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 40 * enemyBalanceHP;
  } else if (type == 3) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 190;
    basicE[enemyIndex].enemyHitY = 58;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 4) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 252;
    basicE[enemyIndex].enemyHitY = 102;
    basicE[enemyIndex].enemyHP = 100 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 100 * enemyBalanceHP;
  } else if (type == 6) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 170;
    basicE[enemyIndex].enemyHitY = 70;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 999) { //level end enemy
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 0;
    basicE[enemyIndex].enemyHitY = 0;
    basicE[enemyIndex].enemyHP = 9999;
    basicE[enemyIndex].enemyHPMax = 9999;
  }
}
 public void processInput() {
  if (screenIndex == 0 && paused == false) {
      if (keyInput[0] == true) { //w
      if (playerY > 10)
        playerY = playerY - (playerMoveY * playerMoveBoost);
      }
      if (keyInput[1] == true) { //s
      if (playerY < 600)
        playerY = playerY + (playerMoveY * playerMoveBoost);
      }
      if (keyInput[2] == true) { //d
      if (playerX < 1200)
        playerX = playerX + (playerMoveX * playerMoveBoost);
      }
      if (keyInput[3] == true) { //a
      if (playerX > 20)
        playerX = playerX - (playerMoveX * playerMoveBoost);
      }
      if (keyInput[4] == true) { //space
        playerShoot();
      }
      if (keyInput[5] == true) { //q, prev weapon
        playerWeapon = 0;
      }
      if (keyInput[6] == true) { //q, next weapon
        playerWeapon = 4;
      }
      if (keyInput[7] == true) { //q, next weapon
        playerWeapon = 1;
      }
      if (keyInput[8] == true) { //p, pause game
        paused = true;
        keyInput[8] = false;
      }
  } else if (screenIndex == 0 && paused == true && levelEnd == false) { //if game is paused and level is not complete
        if (playerState != 255) { //check to ensure player is not dead
          if (keyInput[8] == true) { //p key
            paused = false;
            keyInput[8] = false;
          } 
        } else {
          if (keyInput[7] == true || keyInput[4] == true) { //r key or space key
            levelStart(levelIndex); //restart the current level
            paused = false;
            keyInput[4] = false; //unset space key
          } else if (keyInput[5] == true) { //q key
            //TODO LEVEL EXIT HERE
          }
        }
        
  } else if (screenIndex == 1) {
    if (keyInput[4] == true) screenIndex = 2;
  } else if (screenIndex == 2) {
  
  } else if (screenIndex == 3) {
    if (keyInput[4] == true) {
      advanceVNText();
    }
  }
}

 public void keyPressed() {
  if (key == 'w' || key == 'W')  keyInput[0] = true;
  if (key == 's' || key == 'S')  keyInput[1] = true;
  if (key == 'd' || key == 'D')  keyInput[2] = true;
  if (key == 'a' || key == 'A')  keyInput[3] = true;
  if (key == ' ') keyInput[4] = true;
  if (key == 'q' || key == 'Q')  keyInput[5] = true;
  if (key == 'e' || key == 'E')  keyInput[6] = true;
  if (key == 'r' || key == 'R')  keyInput[7] = true;
  if (key == 'p' || key == 'P')  keyInput[8] = true;
}

 public void keyReleased() {
  if (key == 'w' || key == 'W')  keyInput[0] = false;
  if (key == 's' || key == 'S')  keyInput[1] = false;
  if (key == 'd' || key == 'D')  keyInput[2] = false;
  if (key == 'a' || key == 'A')  keyInput[3] = false;
  if (key == ' ') keyInput[4] = false;
  if (key == 'q' || key == 'Q')  keyInput[5] = false;
  if (key == 'e' || key == 'E')  keyInput[6] = false;
  if (key == 'r' || key == 'R')  keyInput[7] = false;
  if (key == 'p' || key == 'P')  keyInput[8] = false;
}

 public void playerShoot() {
  if (playerWeapon == 0) { //machine gun
    if (timing > playerWeaponCooldown0) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, 0, playerWeapon, 10, 10, playerWeaponPower0 * playerAttack);
      timing = 0;
    }
  } else if (playerWeapon == 1) { //spread shot
    if (timing > playerWeaponCooldown1) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, 0, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, 1, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, 2, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, -2, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, -1, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack);
      timing = 0;
    }
  } else if (playerWeapon == 2) { //dual beam cannon
      if (timing > playerWeaponCooldown2) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY + 7, 20, 0, playerWeapon, 80, 10, playerWeaponPower2 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY - 7, 20, 0, playerWeapon, 80, 10, playerWeaponPower2 * playerAttack);
      timing = 0;
    }
  } else if (playerWeapon == 4) { //sniper shot
      if (timing > playerWeaponCooldown4) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 25, 0, playerWeapon, 100, 5, playerWeaponPower4 * playerAttack);
      timing = 0;
    }
  }
  if (playerSecondWeapon == 0) { //basic secondary missile
    if (secondTiming > playerWeaponCooldown100) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, -10, +10, playerSecondWeapon + 100, 20, 10, playerWeaponPower100 * playerAttack);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, -10, -10, playerSecondWeapon + 100, 20, 10, playerWeaponPower100 * playerAttack);
      secondTiming = 0;
    }
  }
}

 public void mousePressed() {
  if (screenIndex == 2) {//menu screen
    if (areaIndex == 0) {
      if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) screenIndex = 5; //status button
      else if (mouseX > 950 && mouseX < 1250 && mouseY > 125 && mouseY < 200); //mess hall button
      else if (mouseX > 950 && mouseX < 1250 && mouseY > 225 && mouseY < 300); //hanger button
      else if (mouseX > 950 && mouseX < 1250 && mouseY > 325 && mouseY < 400); //engineering buttton
      else if (mouseX > 50 && mouseX < 450 && mouseY > 25 && mouseY < 100) screenIndex = 3; //story button
      else if (mouseX > 50 && mouseX < 450 && mouseY > 125 && mouseY < 200) levelStart(0); //level 00
      else if (mouseX > 50 && mouseX < 450 && mouseY > 225 && mouseY < 300) levelStart(1); //level 01
      else if (mouseX > 50 && mouseX < 450 && mouseY > 325 && mouseY < 400) levelStart(2); //performance test level
      else if (mouseX > 1000 && mouseX < 1200 && mouseY > 450 && mouseY < 650) screenIndex = 4; //settings button
    }
  } else if (screenIndex == 3) { //vn segments
    if (mouseX > 1150 && mouseX < 1250 && mouseY > 650 && mouseY < 690) { //next button
      advanceVNText();
    }
    else if (mouseX > 1040 && mouseX < 1140 && mouseY > 650 && mouseY < 690); //skip button (currently doesnt do anything
  } else if (screenIndex == 4) { //settings menu
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) {screenIndex = 2; saveSettings();} //back button (also saves settings)
    else if (mouseX > 50 && mouseX < 450 && mouseY > 25 && mouseY < 100) oneHitMode = !oneHitMode; //pause on restart button
    else if (mouseX > 50 && mouseX < 450 && mouseY > 225 && mouseY < 300) {image(shadow, 500, 500); image(shadow2, 1000, 500); image(shadow3, 500, 200);} //shadow
    else if (mouseX > 50 && mouseX < 450 && mouseY > 125 && mouseY < 200) damageOnTop = !damageOnTop; //damage on top button
  } else if (screenIndex == 5) { //stats menu
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) screenIndex = 2; //back button
    else if (mouseX > 625 && mouseX < 700 && mouseY > 125 && mouseY < 200) if (playerStatPoints > 0) {playerHPMax = playerHPMax * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 225 && mouseY < 300) if (playerStatPoints > 0) {playerShieldMax = playerShieldMax * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 325 && mouseY < 400) if (playerStatPoints > 0) {playerDefense = playerDefense * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 425 && mouseY < 500) if (playerStatPoints > 0) {playerAttack = playerAttack * 1.05f; playerStatPoints--;}
  }
}
class starsBG {
  int starX;
  int starY;
  int starSpeedX;
  int starSpeedY;

starsBG(int starXtemp, int starYtemp, int starSpeedXtemp, int starSpeedYtemp) {
  starX = starXtemp;
  starY = starYtemp;
  starSpeedX = starSpeedXtemp;
  starSpeedY = starSpeedYtemp;
}

 public void update() {
  starX = starX + starSpeedX;
  starY = starY + starSpeedY;
  if (starX < 0) {
    starY = PApplet.parseInt(random(screenY));
    starX = screenX + 20;
    starSpeedX = PApplet.parseInt(-1 * (random(10) + 1));
  }
}

 public void reset() {
  starX = -200;
  starY = -200;
  starSpeedX = 0;
  starSpeedY = 0;
}

 public void display() {
  if (levelType == 0) {
  } else if (levelType == 1) {
    strokeWeight(5);
    stroke(255, 25);
    fill(255, (150 + (starSpeedX * 10)));
    ellipse(starX, starY, 60, 25);
  } else if (levelType == 2) {
    strokeWeight(5);
    stroke(255, 25);
    fill(255, (150 + (starSpeedX * 10)));
    ellipse(starX, starY, 5, 5);
  }
}
}
//game vars
int buildNumber = 83; //the current build number, should be incremented manually each commit
int screenIndex = 1; //0 = game, 1 = title, 2 = level select, 3 = visual novel story stuff, 4 = settings menu, 5 = status
int levelIndex = 0; //what level the player is playing, 0 is test level
int areaIndex = 0; //index for what area the player is at
int levelType = 1; //0 = over land, 1 = over water, 2 = space
int enemyIndex = 0; //used for enemy gen
int bulletCount = 500; //total bullet objects
int basicECount = 300; //total enemy objects
int dmgCount = 200; //total damage (readout) objects
int starCount = 100; //how many stars to display
int timing = 0; //used for various timings, namely the players weapon firing timer
int secondTiming = 0; //used for timing secondary weapons
int screenX = 1280; //screen size x
int screenY = 720; //screen size y
float autoScroll = -2; //controls how fast the enemies move to the left
float enemyBalanceHP = 1; //multiplier for enemy hp
float enemyBalanceDMG = 1; //multiplier for enemy shot power
float enemyBalanceBump = 5; //multipler for damage to deal when player bumps into an enemy, it is enemyHP * this multiplier
boolean paused = false; //if gameplay is paused this is true
File file; //file used for loading files
boolean useCWD = false; //whether or not to use CWD for file loading/saving (linux only)
int levelEndCheckTimer = 0; //timer to check periodically to see if all enemies are dead
boolean levelEnd = false; //true when on the level end screen

//player var
float playerX = 200; //player x pos
float playerY = 250; //player y pos
int playerHitX = 60; //player x hitbox
int playerHitY = 14; //player y hitbox
int playerBulletOffsetX = 45; //offset for where bullet is generated relative to player model
int playerBulletOffsetY = 13; //offset for where bullet is generated relative to player model
int playerMoveX = 4; //player move speed x
int playerMoveY = 4; //player move speed y
int playerWeapon = 2; //player weapon selected
int playerSecondWeapon = 0; //0 = basic missiles
int playerState = 0; //0 = normal, 1-10 = hurt anim, 255 = dead
int playerAnimTiming = 0; //used for the death anim
int bulletIndex = 0;

float playerShield = 0; //current shield
float playerShieldMax = 50; //max shield
float playerShieldRegen = 0.5f; //shield regen per frame
float playerShieldRegenBoost = 1;//percentage boost for regen
float playerHP = 100; //current hp
float playerHPMax = 100; //max hp
float playerDefense = 1.1f; //percentage damage reduction, goes down
float playerDMGReduction = 1; //calculated from playerDefense
float playerAttack = 1; //percentage boost to all player wpn dmg
float playerCooldown = 1; //percentage boost to defense (reduces damage taken)
float enemyDrop = 1; //percentage of time enemies drop items
float moneyValueDrop = 1; //percentage boost of money dropped
float hpValueDrop = 1; //percentage boost of hp dropped
float xpValueDrop = 1; //percentage boost of xp dropped
float playerMoveBoost = 1; //boost to player speed
float playerXP = 0; //amount of xp player has
int playerLevel = 1; //level of player
float playerMoney = 0; //amount of money player has
int playerStatPoints = 100; //stat points to allocate


//player weapon vars
//machine gun
int playerWeaponCooldown0 = 10;
float playerWeaponPower0 = 5;
int playerWeaponHitX0 = 10;
int playerWeaponHitY0 = 10;
//spread shot
int playerWeaponCooldown1 = 40;
float playerWeaponPower1 = 3.5f;
//dual beam cannon
int playerWeaponCooldown2 = 20;
float playerWeaponPower2 = 5;
//snipe shot
int playerWeaponCooldown4 = 30;
float playerWeaponPower4 = 5;
//basic secondary missile
int playerWeaponCooldown100 = 40;
float playerWeaponPower100 = 10;

//input vars
boolean keyInput[] = new boolean [15];

//visual novel vars
int eventIndex = 0; //index value for events (1 indexed for ease of text editor use)
int textIndex = 2; //index value for which line of dialogue should be displayed, this is 1 indexed, first line is the first start point so start after that
int bgIndex = 0; //background index
int textTiming = 0; //used for rendering each letter individually, ie it looks like its being typed out
String[] textLines = new String[999]; //used for each line of dialogue, this is the raw text in
String[] textLinesO = new String[999]; //used for each line of dialogue, this is after the commands are stripped
int[][] vnInfo = new int[999][5]; //used for stuff like who should be rendered, tint, etc
int commandIndex = 0; //used by the vn command handler to define which level should be skipped to
boolean vnScreenChanges = true; //used to denote whether or not a screen update is needed on the vn segments as to not render frames when nothing has changed
int scriptLength = 0; //used to determine length of script file when its loaded
int[] scriptStartPoints = new int[999]; //used to determine the start point of each script

//animation timing vars
int playerEngineTimer = 0;

//settings vars
boolean oneHitMode = true; //whether to set game to paused when player dies
boolean damageOnTop = false; //whether or not to render to damage on top of the player
 public void drawVN() {
  if (vnScreenChanges == true) {
  background(0);
  scanVNInfo();
  
  switch(vnInfo[textIndex][2]) { //left side vn portrait tint
    case 0:
    tint(255, 255, 255, 255);
    break;
    case 1:
    tint(255, 100);
    break;
  }
  switch(vnInfo[textIndex][0]) { //left side vn portrait image
    case 0:
    image(vnPlayer1r, 0, 0, 500, 500);
    break;
    case 1:
    image(vnPlayer2r, 0, 0, 500, 500);
    break;
    case 5:
    //image(vnSol1r, 0, 0, 500, 500);
    break;
    default:
    break;
  }
  switch(vnInfo[textIndex][3]) { //right side vn portrait tint
    case 0:
    tint(255, 255, 255, 255);
    break;
    case 1:
    tint(255, 100);
    break;
    default:
    break;
  }
  switch(vnInfo[textIndex][1]) { //right side vn portrait image
    case 0:
    image(vnPlayer1, 800, 0, 500, 500);
    break;
    case 1:
    image(vnPlayer2, 800, 0, 500, 500);
    break;
    case 5:
    image(vnSol1, 800, 0, 500, 500);
    break;
    case 10:
    image(vnEsence1, 800, 0, 500, 500);
    break;
    case 11:
    image(vnEsence2, 800, 0, 500, 500);
    break;
    case 12:
    image(vnEsence3, 800, 0, 500, 500);
    break;
    case 13:
    image(vnEsence4, 800, 0, 500, 500);
    break;
    case 20:
    image(vnCyana1, 800, 0, 500, 500);
    break;
    case 21:
    image(vnCyana2, 800, 0, 500, 500);
    break;
    case 22:
    image(vnCyana3, 800, 0, 500, 500);
    break;
    case 23:
    image(vnCyana4, 800, 0, 500, 500);
    break;
    default:
    break;
  }
  tint(255, 255, 255, 255); //reset image tint
  
  strokeWeight(2);
  stroke(255);
  fill(20, 20, 255);
  rect(20, 450, 1240, 250, 20);
  rect(1150, 650, 100, 40, 5);
  rect(1040, 650, 100, 40, 5);
  textSize(48);
  fill(255);
  noStroke();
  text(textLinesO[textIndex - 1], 35, 460, 1230, 250);
  textSize(32);
  text("SKIP", 1050, 680);
  text("NEXT", 1160, 680);
  
  vnScreenChanges = false; //finished rendering frame, do not render again unless changes to frame occur
  }
}

 public int scanVNCommands() { //looks for commands in the script text, this is run when text is advanced
  char[] ch = textLines[textIndex-1].toCharArray();
  if (ch[0] == '-' && ch[1] == 'l') { //load level
    commandIndex = (ch[3] - '0') * 10 + (ch[4] - '0');
    return 0; //the command to load a level
  } else if (ch[0] == '-' && ch[1] == 's') { //text start point
    textIndex++; //advance text to skip past start point line
  }
  return 255;
}

 public void scanForStartPoints() {
  int index = 0; //used to increment the start points array, ie 0 would be the first start point, note the text after -s does not matter only the order in the file they appear
  for (int i = 0; i < scriptLength; i++) {
    char[] ch = textLines[i].toCharArray();
    if (ch[0] == '-' && ch[1] == 's') { //text blurb start point
      scriptStartPoints[index] = i+1+1; //textLines is a 1 incremented array, add another 1 so it starts the line after the start point line
      println(scriptStartPoints[index]);
      index++;
    }
  }
  println(scriptStartPoints[2]);
}

 public void advanceVNText() { //moves vn forward, reads commands, etc
  textIndex++; //advance the text script
  if (scanVNCommands() == 0) {//load level
    levelStart(commandIndex); //load a level
  }
  vnScreenChanges = true; //trigger a new vn frame rendering
  keyInput[4] = false; //release space key
}

 public void scanVNInfo() { //scans the script text for the vn portrait info
  char[] ch = textLines[textIndex-1].toCharArray();
  if (ch[0] != '-') { //ensure line is not a command
    vnInfo[textIndex][0] = (ch[0] - '0') * 10 + (ch[1] - '0'); //left vn portrait
    vnInfo[textIndex][1] = (ch[3] - '0') * 10 + (ch[4] - '0'); //right vn portrait
    vnInfo[textIndex][4] = (ch[6] - '0'); //tint, who is 
    
    //translate into vnInfo format that is used in drawVN
    if (vnInfo[textIndex][4] == 0) { //left side talking
    vnInfo[textIndex][2] = 0;
    vnInfo[textIndex][3] = 1;
  } else if (vnInfo[textIndex][4] == 1) { //right side talking
    vnInfo[textIndex][2] = 1;
    vnInfo[textIndex][3] = 0;
  } else if (vnInfo[textIndex][4] == 2) { //no one talking
    vnInfo[textIndex][2] = 1;
    vnInfo[textIndex][3] = 1;
  }
  
  char[] chStripped = new char[ch.length-7]; //makes a new char array for text stripping
  for(int i = 7; i < ch.length; i++) { //strips the first 7 chars
    chStripped[i-7] = ch[i];
  }
  textLinesO[textIndex-1] = String.valueOf(chStripped); //dumps the char into a string
} else textLinesO[textIndex-1] = "this line is a command [error]";
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "edge_of_solaris" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
