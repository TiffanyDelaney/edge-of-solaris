/* autogenerated by Processing revision 1282 on 2022-03-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class edge_of_solaris extends PApplet {

bullet[] blts;
enemy[] basicE;
starsBG[] stars;
damage[] dmg;

PImage faun1;
PImage faun2;
PImage faun3;
PImage faun4;
PImage faun5;
PImage faun6;
PImage player1;
PImage vnPlayer1;
PImage vnPlayer2;
PImage vnPlayer1r;
PImage vnPlayer2r;
PImage vnSol1;
PImage vnSol2;
PImage vnSol3;
PImage vnSol1r;
PImage vnSol2r;
PImage vnSol3r;
PImage vnEsence1;
PImage vnEsence2;
PImage vnEsence3;
PImage vnEsence4;
PImage vnEsence1r;
PImage vnEsence2r;
PImage vnEsence3r;
PImage vnEsence4r;
PImage vnVeda1;
PImage vnVeda2;
PImage vnVeda3;
PImage vnVeda4;
PImage vnVeda1r;
PImage vnVeda2r;
PImage vnVeda3r;
PImage vnVeda4r;
PImage vnCyana1;
PImage vnCyana2;
PImage vnCyana3;
PImage vnCyana4;
PImage settingsBtn;
PImage shadow;
PImage shadow2;
PImage shadow3;
PImage shadow4;

PrintWriter settingsOut;
PrintWriter OSver;
JSONObject settingsJSON;
JSONObject gamesaveJSON;
JSONArray levelEditorSaveJSON;



 public void setup(){
  /* size commented out by preprocessor */;
  frameRate(60);
  blts = new bullet[bulletCount];
  basicE = new enemy[basicECount];
  stars = new starsBG[starCount];
  dmg = new damage[dmgCount];
  initObjects(); //initializes all objects to "default" values
  loadText(); //load the text file for visual novel text
  loadSprites(); //load in png images for sprites
  loadSave(); //load the gamesave.sav file
  scanForStartPoints(); //scan the script for the segment start points
  calcWeaponStats(); //calculates weapon power from level and weapon upg cost
  placeEnemies();
}

 public void draw() {
  processInput();
  drawFrame();
  drawUI();
  if (screenIndex == 3) {
    fill(0);
    rect(0, 0, 100, 50);
  }
  fill(200, 50, 50);
  textSize(24);
  text(frameRate, 20, 20);
  if (paused == false) {
    if (timing < 255) timing++;
    if (secondTiming < 255) secondTiming++;
  }
}

 public void drawFrame() {
  if (screenIndex == 0) {
    if (paused == false) {
     //render background
     if (levelType == 1) background(180, 248, 255);
     else if (levelType == 2) background(0);
      
    if (levelType == 2 || levelType == 1) {
      for (starsBG stars : stars) {
        stars.update();
        stars.display();
      }
    }
    
    for (enemy basicE : basicE) {
      basicE.update();
      basicE.collision();
      basicE.shoot();
      basicE.display();
    }
    for (bullet blts : blts) {
      blts.update();
      blts.display();
    }
    for (damage dmg : dmg) {
      dmg.update();
    }
    if (damageOnTop ==false) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    
    if (levelType == 0) { //over land
      
    } else if (levelType == 1) { //over water
      noStroke();
      fill(50, 50, 255);
      ellipse(640, 750, 2000, 200);
    } 
    levelEndCheckTimer++;
    if (levelEndCheckTimer > 60) { //check to see if all enemies are dead once a second
      levelEndCheckTimer = 0;
      for (int i = 0; i < basicECount; i++) {
        if (basicE[i].enemyState != 2) {
          break; //break out of loop for efficiency
        }else if (i == (basicECount - 1)) {
          levelEnd = true; //switch to level end screen
          keyInput[4] = false; //release space key
          paused = true; //put game in paused state
          break; //break out of loop for efficiency
        }
      }
    }
    
    //draw player
    playerCollision();
    if (playerShield < playerShieldMax) playerShield = playerShield + playerShieldRegen; //regen shield if depleted
    if (playerShield > playerShieldMax) playerShield = playerShieldMax; //ensure shield does not increase past max
    if (playerState == 0) setRect(1); //if player not being hurt
    else { //if player being hurt
      setRect(2); 
      playerState--;  //reset player state
      rect(playerX, playerY + 10, playerHitX, playerHitY - 10, 10); //render player hurt state
    }
    
    if (playerHP <= 0) { //if player dies
      paused = true; //pause game
      playerState = 255; //set player as dead
      playerAnimTiming = 30; //set timer for death anim
      keyInput[4] = false; //unset space key
    }
    
    //render the engine glow effect
    noStroke();
    fill(0, 127, 255, 100);
    ellipse(playerX - 6, playerY + 12.5f, 30 + abs(playerEngineTimer / 3), 10);
    fill(0, 165, 255, 120);
    ellipse(playerX - 3, playerY + 12.5f, 20 + abs(playerEngineTimer / 3), 10);
    fill(60, 240, 255, 150);
    ellipse(playerX - 1, playerY + 12.5f, 15 + abs(playerEngineTimer / 3), 8);
    fill(100, 240, 255, 200);
    ellipse(playerX - 1, playerY + 12.5f, 10 + abs(playerEngineTimer / 3), 6);
    playerEngineTimer++;
    if (playerEngineTimer == 15) playerEngineTimer = -15;
    
    if (shadowFactor > 12) image(shadow4, playerX - 5, playerY - 5, playerHitX * 2, playerHitY * 2);
    else image(player1, playerX - 5, playerY - 5); //player sprite
    
    if (damageOnTop == true) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    } else if (paused == true) { //if game is paused
           //render background
     if (levelType == 1) background(180, 248, 255);
     else if (levelType == 2) background(0);
      
    if (levelType == 2 || levelType == 1) {
      for (starsBG stars : stars) {
        stars.display();
      }
    }
    
    for (enemy basicE : basicE) {
      basicE.display();
    }
    for (bullet blts : blts) {
      blts.display();
    }
    if (damageOnTop == false) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    if (levelType == 0) { //over land
      
    } else if (levelType == 1) { //over water
      noStroke();
      fill(50, 50, 255);
      ellipse(640, 750, 2000, 200);
    }
    if (playerState == 255) { //if player dead
      if (playerAnimTiming != 0) {
        fill(255, 127, 0, 100);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 5), (playerHitY / 2) + (playerAnimTiming * 3));
        fill(255, 165, 0, 120);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 4), (playerHitY / 2) + (playerAnimTiming * 2));
        fill(255, 240, 60, 150);
        ellipse(playerX + 30, playerY + 7, (playerHitX / 3) + (playerAnimTiming * 3), (playerHitY / 2) + (playerAnimTiming * 1));
        playerAnimTiming--;
      }
      textSize(60);
      fill(255, 50, 50);
      text("YOU DIED", 550, 350);
      textSize(48);
      text("Press R or Space to restart", 400, 450);
      
    } else {
      if (shadowFactor > 12) image(shadow4, playerX - 5, playerY - 5, playerHitX * 2, playerHitY * 2);
      else image(player1, playerX - 5, playerY - 5); //player sprite
      if (levelEnd == true) { //if on level end screen
      textSize(60);
      fill(255, 50, 50);
      text("Level Complete", 550, 350);
      textSize(48);
      text("Press Space to continue", 490, 450);
      if (keyInput[4] == true) levelEnd();
    } else { //if paused, player not dead and level not complete
      textSize(60);
      fill(255, 50, 50);
      text("PAUSED", 550, 350);
    }
    }
    if (damageOnTop == true) {
      for (damage dmg : dmg) {
        dmg.display();
      }
    }
    
    
    }
  } else if (screenIndex == 1) {
    resetObjects(); //reset objects on non game screens 
  } else if (screenIndex == 3) {
    drawVN();
  }
}

 public void drawUI() {
  if (screenIndex == 0) { //in game
    
    //render hp and shield bars
    if (oneHitMode == false) {
      stroke(0);
      strokeWeight(15);
      fill(0);
      rect(20, 650, 200, 50, 10);
      rect(235, 650, 200, 50, 10);
      setRect(4);
      if (playerHP >= 0) rect(23, 653.5f, (195 * (playerHP / playerHPMax)), 44);
      setRect(5);
      rect(238, 653.5f, (194 * (playerShield / playerShieldMax)), 44);
      setRect(3); //render surrounds
      noFill();
      rect(20, 650, 200, 50, 10);
      rect(235, 650, 200, 50, 10);
      fill(0);
    }
    
    //render weapon selector
    stroke(255);
    strokeWeight(2);
    rect(450, 653, 30, 20, 5);
    rect(450, 678, 30, 20, 5);
    rect(485, 653, 30, 20, 5);
    rect(485, 678, 30, 20, 5);
  } else if (screenIndex == 1) { //title page
    background(0);
    fill(200, 200, 255, 120);
    textSize(130);
    text("Edge Of Solaris", 240, 120);
    text("Edge Of Solaris", 248, 120);
    fill(200, 200, 255, 255);
    textSize(128);
    text("Edge Of Solaris", 250, 120);
    fill(200, 200, 255);
    textSize(90);
    text("random tagline in space", 200, 240);
    textSize(64);
    text("new game", 500, 400);
    text("continue", 500, 500);
    text("press space to continue (temp)", 50, 650);
    textSize(24);
    text("build " + buildNumber, 1175, 700);
  } else if (screenIndex == 2) { //level select
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(950, 125, 300, 75);
    rect(950, 225, 300, 75);
    rect(950, 325, 300, 75);
    rect(950, 425, 300, 75);
    rect(950, 525, 300, 75);
    //draw level select rects
    rect(50, 25, 700, 75);
    rect(50, 125, 700, 75);
    rect(50, 225, 700, 75);
    rect(50, 325, 700, 75);
    rect(50, 425, 700, 75);
    
    if (playerStatPoints > 0) { //check if stat points to spend
      fill(255, 0, 0);
      noStroke();
      ellipse(1212.5f, 62.5f, 50, 50); //draw red circle to indicate stat points to spend
    }
    //draw text
    noStroke();
    fill(255);
    textSize(48);
    text("status", 975, 75);
    text("mess hall", 975, 175);
    text("hanger", 975, 275);
    text("engineering", 975, 375);
    text("settings", 975, 475);
    text("save game", 975, 575);
    if (areaIndex == 0) {
      text("launch story", 75, 75);
      text("level 00", 75, 175);
      text("level 01", 75, 275);
      text("test level", 75, 375);
      text("test level 2", 75, 475);
      
    } else if (areaIndex == 1) { //first area
      text("start the story", 75, 75);
      text("go to level editor", 75, 375);
      text("go to debug level select", 75, 475);
    } 
  } else if (screenIndex == 4) { //settings menu
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(50, 25, 400, 75);
    if (oneHitMode == true) {
      fill(0, 150, 0);
    }
    rect(475, 25, 75, 75);
    fill(50, 0, 50); // reset color
    if (damageOnTop == true) {
      fill(0, 150, 0);
    }
    rect(475, 125, 75, 75);
    fill(50, 0, 50); // reset color
    rect(50, 125, 400, 75);
    rect(50, 225, 400, 75);
    //draw options button
    noStroke();
    fill(255);
    textSize(48);
    text("Back", 975, 75);
    text("one hit mode", 75, 75);
    text("damage on top", 75, 175);
    text("shadow", 75, 275);
  } else if (screenIndex == 5) { //status window
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(50, 25, 400, 75);
    rect(50, 125, 400, 75);
    rect(50, 225, 400, 75);
    rect(50, 325, 400, 75);
    rect(50, 425, 400, 75);
    
    rect(475, 25, 125, 75);
    rect(475, 125, 125, 75);
    rect(475, 225, 125, 75);
    rect(475, 325, 125, 75);
    rect(475, 425, 125, 75);
    
    rect(625, 125, 75, 75);
    rect(625, 225, 75, 75);
    rect(625, 325, 75, 75);
    rect(625, 425, 75, 75);
    //draw options button
    noStroke();
    fill(255);
    textSize(48);
    text("Back", 975, 75);
    text("total stat points", 75, 75);
    text("hp", 75, 175);
    text("shield", 75, 275);
    text("defense", 75, 375);
    text("attack", 75, 475);
    
    text("XP: " + playerXP, 75, 575);
    text("level: " + playerLevel, 75, 675);
    text("xp next level: " + pow(playerLevel + 1, 3), 500, 575);
    
    text("+", 650, 175);
    text("+", 650, 275);
    text("+", 650, 375);
    text("+", 650, 475);
    
    text(playerStatPoints, 490, 75);
    text((int)playerHPMax, 490, 175);
    text((int)playerShieldMax, 490, 275);
    text((int)(playerDefense * 100), 490, 375);
    text((int)(playerAttack * 100), 490, 475);
  } else if (screenIndex == 8) { //engineering
    background(0);
    stroke(255);
    strokeWeight(10);
    fill(50, 0, 50);
    //draw menu rects
    rect(950, 25, 300, 75);
    rect(950, 125, 300, 175);
    //draw level select rects
    rect(50, 25, 400, 175);
    rect(50, 225, 400, 175);
    rect(50, 425, 400, 175);
    
    rect(475, 25, 400, 175);
    rect(475, 225, 400, 175);
    rect(475, 425, 400, 175);
    
    noStroke();
    fill(255);
    textSize(48);
    text("Back", 975, 75);
    text("Money:", 975, 175);
    text("$" + playerMoney, 975, 275);
    
    textSize(16);
    text("Dual Beam Cannon (per bullet stats)", 60, 45);
    text("Bullet Count: 2", 60, 65);
    text("Current Damage per Bullet: " + playerWeaponPower2, 60, 85);
    text("Upgraded Damage per Bullet: " + (playerWeaponPower2 * 1.1f), 60, 105);
    text("Current Damage per Second: " + (playerWeaponPower2 * (60/playerWeaponCooldown2)), 60, 125);
    text("Upgraded Damage per Second: " + (playerWeaponPower2 * 1.1f * (60/playerWeaponCooldown2)), 60, 145);
    text("Current Bullets per second: " + (60/playerWeaponCooldown2), 60, 165);
    text("Click here to Upgrade Weapon: $" + playerWeaponCost2, 60, 185); 
    
    if (playerWeaponsUnlocked >= 1) {
      text("Machine Gun (per bullet stats)", 60, 245);
      text("Bullet Count: 1", 60, 265);
      text("Current Damage per Bullet: " + playerWeaponPower0, 60, 285);
      text("Upgraded Damage per Bullet: " + (playerWeaponPower0 * 1.1f), 60, 305);
      text("Current Damage per Second: " + (playerWeaponPower0 * (60/playerWeaponCooldown0)), 60, 325);
      text("Upgraded Damage per Second: " + (playerWeaponPower0 * 1.1f * (60/playerWeaponCooldown0)), 60, 345);
      text("Current Bullets per second: " + (60/playerWeaponCooldown0), 60, 365);
      text("Click here to Upgrade Weapon: $" + playerWeaponCost0, 60, 385); 
      if (playerWeaponsUnlocked >= 2) {
        text("Heavy Laser (per bullet stats)", 60, 445);
        text("Bullet Count: 1", 60, 465);
        text("Current Damage per Bullet: " + playerWeaponPower4, 60, 485);
        text("Upgraded Damage per Bullet: " + (playerWeaponPower4 * 1.1f), 60, 505);
        text("Current Damage per Second: " + (playerWeaponPower4 * (60/playerWeaponCooldown4)), 60, 525);
        text("Upgraded Damage per Second: " + (playerWeaponPower4 * 1.1f * (60/playerWeaponCooldown4)), 60, 545);
        text("Current Bullets per second: " + (60/playerWeaponCooldown4), 60, 565);
        text("Click here to Upgrade Weapon: $" + playerWeaponCost4, 60, 585); 
        if (playerWeaponsUnlocked >= 3) {
          text("Shotgun (per bullet stats)", 485, 45);
          text("Bullet Count: 5", 485, 65);
          text("Current Damage per Bullet: " + playerWeaponPower1, 485, 85);
          text("Upgraded Damage per Bullet: " + (playerWeaponPower1 * 1.1f), 485, 105);
          text("Current Damage per Second: " + (playerWeaponPower1 * (60/playerWeaponCooldown1)), 485, 125);
          text("Upgraded Damage per Second: " + (playerWeaponPower1 * 1.1f * (60/playerWeaponCooldown1)), 485, 145);
          text("Current Bullets per second: " + (60/playerWeaponCooldown1), 485, 165);
          text("Click here to Upgrade Weapon: $" + playerWeaponCost1, 485, 185); 
        }
      }
    }
  } else if (screenIndex == 9) { //level editor window
    levelEditor();
  }
}

 public void levelEnd() { //called when the level should end
  keyInput[4] = false; //release space key
  levelEnd = false; //turn off level end trigger
  paused = false; //unpause game
  if (levelEditorMode == false) {
  checkForLevelUp(); //check if player leveled up
  if (levelIndex == 0) level0Completed = true;
  if (levelIndex == 1) level1Completed = true;
  if (levelIndex == 1 && playerWeaponsUnlocked == 0) {playerWeaponsUnlocked = 1; areaIndex = 2;} //unlock the mg after level 1 complete and set area to 2
  scanLevelEndCommands();
  } else {
    playerHP = playerHPMax; //restore player hp
    playerX = 200;
    playerY = 250;
    screenIndex = 9; //set to level editor screen
    //redraw enemies
    initObjects(); //reset all enemies
    for(int i = 0; i < levelEnemyIndex; i++) {
        genEnemy(levelEnemyType[i], levelEnemyX[i], levelEnemyY[i]);
    }
  }
}

 public void levelStart(int cmdIndex) {
  levelIndex = cmdIndex;
  screenIndex = 0;
  playerX = 200;
  playerY = 250;
  playerHP = playerHPMax;
  playerShield = playerShieldMax;
  playerState = 0;
  initObjects();
  placeEnemies();
  
  //calculate stats
  if (oneHitMode == true) enemyBalanceDMG = 9000;
  playerDMGReduction = 1 - ((playerDefense - 1) * 0.1f);
  if (playerDMGReduction <= 0.30f) playerDMGReduction = 0.30f;
  playerShieldRegen = (playerShieldMax / 100) * playerShieldRegenBoost;
}

 public void checkForLevelUp() { //check to see if the player just leveled up
  if ((int)Math.cbrt(playerXP) > playerLevel) { //if player leveled up
    playerLevel = (int)Math.cbrt(playerXP); //set the level to new level
    playerStatPoints = playerStatPoints + 4; //add 4 stat points
  }
}

 public void calcWeaponStats() { //calculate weapon stats and costs
  playerWeaponPower0 = playerWeaponBasePower0;
  playerWeaponPower1 = playerWeaponBasePower1;
  playerWeaponPower2 = playerWeaponBasePower2;
  playerWeaponPower4 = playerWeaponBasePower4;
  for (int i = 0; i < playerWeaponLevel0; i++) {
    playerWeaponPower0 = playerWeaponPower0 * 1.1f;
  }
  for (int i = 0; i < playerWeaponLevel1; i++) {
    playerWeaponPower1 = playerWeaponPower1 * 1.1f;
  }
  for (int i = 0; i < playerWeaponLevel2; i++) {
    playerWeaponPower2 = playerWeaponPower2 * 1.1f;
  }
  for (int i = 0; i < playerWeaponLevel4; i++) {
    playerWeaponPower4 = playerWeaponPower4 * 1.1f;
  }
  playerWeaponCost0 = (int)pow(playerWeaponLevel0 * 10, 3);
  playerWeaponCost1 = (int)pow(playerWeaponLevel1 * 10, 3);
  playerWeaponCost2 = (int)pow(playerWeaponLevel2 * 10, 3);
  playerWeaponCost4 = (int)pow(playerWeaponLevel4 * 10, 3);
}

 public void setRect(int colorIndex) {
  if (colorIndex == 0) {
    strokeWeight(1);
    noStroke();
    fill(0);
  } else if (colorIndex == 1) { //used for player ship rendering
    strokeWeight(1);
    noStroke();
    fill(255);
  } else if (colorIndex == 2) { //used for player hurt rendering
    strokeWeight(10);
    stroke(200, 0, 0, 100);
    fill(255, 200, 200);
  } else if (colorIndex == 3) { //used for hp surround
    strokeWeight(6);
    fill(0);
    stroke(255);
  } else if (colorIndex == 4) { //used for hp bar fill
    noStroke();
    fill(20, 255, 20);
  } else if (colorIndex == 5) {
    noStroke();
    fill(20, 20, 255);
  }
}

 public void initObjects() { //set all objects to default (meant to be run in setup)
  for (int i = 0; i < bulletCount; i++) {
    blts[i] = new bullet(-20, -20, 0, 0, 255, 0, 0, 0, 0);
  }
  for (int i = 0; i < basicECount; i++) {
    basicE[i] = new enemy(-200, -200, 0, 0, 255, 0, 0, 10, 10, 0, 2, 0);
  }
  for (int i = 0; i < starCount; i++) {
    stars[i] = new starsBG(PApplet.parseInt(random(screenX + 20)), PApplet.parseInt(random(screenY)), PApplet.parseInt(-1 * (random(10) + 1)), 0);
  }
  for (int i = 0; i < dmgCount; i++) {
    dmg[i] = new damage(-200, -200, 0, 0, 0);
  }
}

 public void resetObjects() { //resets objects (similar to init but meant to be run in main loop)
    for (starsBG stars : stars) {
      stars.reset();
    }
    for (enemy basicE : basicE) {
      basicE.reset();
    }
    for (bullet blts : blts) {
      blts.reset();
    }
    for (damage dmg : dmg) {
      dmg.reset();
    }
}

 public void playerCollision() { //check collision with enemy bullets/ships
    for (int i = 0; i < bulletCount; i++) {
   if (blts[i].bulletType == 200 || blts[i].bulletType == 201) { //check to ensure bullet is an enemy bullet
    if (playerX <= blts[i].bulletX + (blts[i].bulletHitX / 2)) {
      if ((playerX + (playerHitX / 1)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (playerY + 10 <= blts[i].bulletY + (blts[i].bulletHitY / 2)) {
          if ((playerY + (playerHitY / 1)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
              playerState = 10;
              playerShield = playerShield - (blts[i].bulletPower * playerDMGReduction);
              dmg[findDamage()] = new damage(playerX - 10, playerY - 20, (blts[i].bulletPower * playerDMGReduction), 1, 30);
              if (playerShield < 0) { //if shield goes negative
                playerHP = playerHP - abs(playerShield); //subtract the difference of how negative the shield is
                playerShield = 0; //make sure player shield does not go negative
              }
            
            if (blts[i].bulletType == 200) blts[i].reset();
          }
        }
      }
    }
  }
  }
  for (int i = 0; i < basicECount; i++) { //check collision with enemy planes
   if (basicE[i].enemyState != 2) { //check to ensure ship is not dead
    if (playerX <= basicE[i].enemyX + (basicE[i].enemyHitX / 2)) {
      if ((playerX + (playerHitX / 1)) >= (basicE[i].enemyX - (basicE[i].enemyHitX / 2))) {
        if (playerY + 10 <= basicE[i].enemyY + (basicE[i].enemyHitY / 2)) {
          if ((playerY + (playerHitY / 1)) >= (basicE[i].enemyY - (basicE[i].enemyHitY / 2))) {
              playerState = 10;
              playerShield = playerShield - (basicE[i].enemyHP * enemyBalanceBump * enemyBalanceDMG * playerDMGReduction);
              dmg[findDamage()] = new damage(playerX - 10, playerY - 20, (basicE[i].enemyHP * enemyBalanceBump * enemyBalanceDMG * playerDMGReduction), 1, 30);
              if (playerShield < 0) { //if shield goes negative
                playerHP = playerHP - abs(playerShield); //subtract the difference of how negative the shield is
                playerShield = 0; //make sure player shield does not go negative
              }
            //kill enemy
            basicE[i].enemyHP = 0;
            basicE[i].enemyState = 2;
            basicE[i].enemyTiming = 30;
          }
        }
      }
    }
  }
  }
}

 public int findBullet () { //finds next unused bullet and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (blts[i].bulletType == 255) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (bulletCount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}

 public int findEnemy () { //finds next unused enemy and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (basicE[i].enemyState == 2) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (basicECount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}

 public int findDamage () { //finds next unused enemy and returns its index value as an int
    bulletIndex = 0;
    int i = 0;
    boolean exit = false;
    while (exit == false) {
      if (dmg[i].damageTimer == 0) {
        bulletIndex = i;
        exit = true;
      } else i++;
      if (i > (dmgCount - 1)) {
        bulletIndex = 0;
        exit = true;
      }
    }
  return bulletIndex;
}
class bullet {
  float bulletX; //bullet x pos
  float bulletY; //bullet y pos
  float bulletSpeedX; //bullet x speed
  float bulletSpeedY; //bullet y speed
  int bulletType; //255 = dead/inactive bullet, 0-199 = player bullets, 200-254 = enemy bullets
  int bulletHitX; //bullet hitbox x
  int bulletHitY; //bullet hitbox y
  float bulletPower; //bullet impact damage (defined on bullet gen)
  int bulletTimer; //used for timed bullet functions

bullet(float bulletXtemp, float bulletYtemp, float bulletSpeedXtemp, float bulletSpeedYtemp, int bulletTypetemp, int bulletHitXtemp, int bulletHitYtemp, float bulletPowertemp, int bulletTimertemp) {
  bulletX = bulletXtemp;
  bulletY = bulletYtemp;
  bulletSpeedX = bulletSpeedXtemp;
  bulletSpeedY = bulletSpeedYtemp;
  bulletType = bulletTypetemp;
  bulletHitX = bulletHitXtemp;
  bulletHitY = bulletHitYtemp;
  bulletPower = bulletPowertemp;
  bulletTimer = bulletTimertemp;
}

 public void update() {
  if (bulletX > (screenX + 100) || bulletX < -100 || bulletY > (screenY + 100) || bulletY < -100) bulletType = 255; //destroy bullet if off screen
  else { //if bullet is not off screen, update bullet position and timer
    bulletX = bulletX + bulletSpeedX; //update bullet x according to x speed
    bulletY = bulletY + bulletSpeedY; //update bullet y according to y speed
    bulletTimer++; //increment bullet's timer if bullet is alive
  }
  if (bulletType == 100) { //basic secondary rockets
    if (bulletSpeedY > 0) bulletSpeedY--;
    if (bulletSpeedY < 0) bulletSpeedY++;
    if (bulletSpeedX < 5) bulletSpeedX++;
  } else if (bulletType == 101) { //tracking secondary missiles
    float enemyDistance = 999999999; //how far away is the enemy
    float enemyDistanceX; //distance from enemy x
    float enemyDistanceY; //distance from enemy y
    int enemyTargetIndex = 9999; //which enemy is being targeted
    for (int i = 0; i < basicECount; i++) {
      if (basicE[i].enemyState != 2) { //confirm enemy is not dead
        enemyDistanceX = abs(basicE[i].enemyX - bulletX); //find difference on x axis
        enemyDistanceY = abs(basicE[i].enemyY - bulletY); //find difference on y axis
        float enemyDistanceNew = sqrt(pow(enemyDistanceX, 2) + pow(enemyDistanceY, 2));
        if (enemyDistanceNew < enemyDistance) { //if current enemy distance is less than previous enemy distance
          enemyDistance = enemyDistanceNew; //set current closest distance to current distance
          enemyTargetIndex = i; //set the current targeted enemy to be this enemy
        }
      }
    }
    if (enemyDistance != 999999999 && enemyTargetIndex != 9999) { //basically just checks if the above loop actually found an enemy
      if (basicE[enemyTargetIndex].enemyX < 1250) {
        float speed = 0.1f; //higher numbers are slower
        int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
        int offsetY = 10; //account for incorrect aim
        enemyDistance = enemyDistance * speed; //scale c (distance hypotenuse) to speed
        float speedX = (basicE[enemyTargetIndex].enemyX - bulletX + offsetX);
        float speedY = (basicE[enemyTargetIndex].enemyY - bulletY + offsetY);
        float bulletSpeedXNew = speedX / (enemyDistance);
        float bulletSpeedYNew = speedY / (enemyDistance);
        if (bulletSpeedXNew < bulletSpeedX) bulletSpeedX = bulletSpeedX - 0.1f;
        if (bulletSpeedXNew > bulletSpeedX) bulletSpeedX = bulletSpeedX + 0.1f;
        if (bulletSpeedYNew < bulletSpeedY) bulletSpeedY = bulletSpeedY - 0.1f;
        if (bulletSpeedYNew > bulletSpeedY) bulletSpeedY = bulletSpeedY + 0.1f;
      }
    }
  } else if (bulletType == 1) { //shotgun/spread shot
    bulletHitX = PApplet.parseInt(10 - pow(1.030f, bulletTimer));
    bulletHitY = PApplet.parseInt(10 - pow(1.030f, bulletTimer));
    bulletPower = (playerWeaponPower1 * playerAttack) - pow(1.030f, bulletTimer);
    if (bulletHitX < 1) bulletType = 255; //kill bullet if too small
  } else if (bulletType == 200) { //basic enemy bullet
    
  }
}

public void reset() {
  bulletX = -20;
  bulletY = -20;
  bulletSpeedX = 0;
  bulletSpeedY = 0;
  bulletType = 255;
  bulletHitX = 0;
  bulletHitY = 0;
  bulletPower = 0;
  bulletTimer = 0;
}

 public void explode() {
}

 public void display() {
  if (bulletType == 0) { //machine gun
    stroke(20, 20, 200, 120);
    strokeWeight(2);
    fill(20, 20, 200);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 1) { //spread shot
    noStroke();
    fill(139, 69, 19, 200);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    stroke(220, 220, 20, 120);
    strokeWeight(2);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 4) { //snipe shot
    noStroke();
    fill(20, 20, 255, 200);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    stroke(255, 120);
    strokeWeight(10);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 100) { //basic secondary missile
    stroke(255, 20, 20, 200);
    strokeWeight(3);
    fill(255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }else if (bulletType == 101) {   
    stroke(255, 77, 0, 150);
    strokeWeight(3);
    fill(255, 77, 0, 150);
    ellipse(bulletX - (bulletSpeedX / 1), bulletY - (bulletSpeedY / 1), bulletHitX - 1, bulletHitY - 1);
    
    stroke(255, 77, 0, 100);
    strokeWeight(3);
    fill(255, 77, 0, 100);
    ellipse(bulletX - (bulletSpeedX / 0.5f), bulletY - (bulletSpeedY / 0.5f), bulletHitX - 1   , bulletHitY - 1);
    
    stroke(155, 77, 0, 50);
    strokeWeight(3);
    fill(255, 77, 0, 50);
    ellipse(bulletX - (bulletSpeedX / 0.35f), bulletY - (bulletSpeedY / 0.35f), bulletHitX - 1   , bulletHitY - 1);
    
    stroke(255, 2, 255, 200);
    strokeWeight(3);
    fill(255, 200, 220);
    ellipse(bulletX - (bulletSpeedX / 2), bulletY - (bulletSpeedY / 2), bulletHitX, bulletHitY);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 2) { //dual beam cannon
    stroke(20, 20, 200, 150);
    strokeWeight(2);
    fill(100, 100, 255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 200) { //basic enemy shot
    stroke(20, 200, 20, 150);
    strokeWeight(2);
    fill(20, 255, 20, 150);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    fill(175, 255, 175);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  } else if (bulletType == 201) { //enemy energy shot (enemyindex 7)
    stroke(20, 20, 200, 150);
    strokeWeight(2);
    fill(20, 20, 255, 150);
    ellipse(bulletX, bulletY, bulletHitX + 5, bulletHitY + 5);
    fill(175, 175, 255);
    ellipse(bulletX, bulletY, bulletHitX, bulletHitY);
  }
}
}
class damage {
  float damageX;
  float damageY;
  float damage;
  int damageType;
  int damageTimer;
  
  damage(float damageXtemp, float damageYtemp, float damagetemp, int damageTypetemp, int damageTimertemp) {
    damageX = damageXtemp;
    damageY = damageYtemp;
    damage = damagetemp;
    damageType = damageTypetemp;
    damageTimer = damageTimertemp;
  }
  
   public void update() {
    if (damageTimer != 0) {
      damageTimer--;
      damageY--;
    }
  }
  
   public void display() {
    if (damageTimer != 0) {
      if (damageType == 0) {
        int fade = damageTimer * 8;
        if (fade > 255) fade = 255;
        noStroke();
        textSize(24);
        fill(255, 20, 20, fade);
        text(damage, damageX, damageY);
      } else if (damageType == 1) {
        int fade = damageTimer * 8;
        if (fade > 255) fade = 255;
        noStroke();
        textSize(24);
        fill(200, 20, 255, fade);
        text(damage, damageX, damageY);
      }
    }
  }
  
   public void reset() {
    damageX = -200;
    damageY = -200;
    damage = 0;
    damageType = 0;
    damageTimer = 0;
  }
}
class enemy {
  float enemyX; //enemy x pos
  float enemyY; //enemy y pos
  float enemySpeedX; //enemy x speed
  float enemySpeedY; //enemy y speed
  int enemyType; //type of enemy, 0 = basic, 1 = big, 2 = modema ship
  float enemyHitX; //enemy hitbox x
  float enemyHitY; //enemy hitbox y
  float enemyHP; //enemy current hp
  float enemyHPMax; //enemy max hp
  int enemyTiming; //enemy timing, used for projectile shot timing
  int enemyState; //0 = normal, 1 = hurt, 2 = dead
  float enemyMoveTiming; //used to move enemies in various ways

enemy(int enemyXtemp, int enemyYtemp, int enemySpeedXtemp, int enemySpeedYtemp, int enemyTypetemp, int enemyHitXtemp, int enemyHitYtemp, float enemyHPtemp, float enemyHPMaxtemp, int enemyTimingtemp, int enemyStatetemp, int enemyMoveTimingtemp) {
  enemyX = enemyXtemp;
  enemyY = enemyYtemp;
  enemySpeedX = enemySpeedXtemp;
  enemySpeedY = enemySpeedYtemp;
  enemyType = enemyTypetemp;
  enemyHitX = enemyHitXtemp;
  enemyHitY = enemyHitYtemp;
  enemyHP = enemyHPtemp;
  enemyHPMax = enemyHPMaxtemp;
  enemyTiming = enemyTimingtemp;
  enemyState = enemyStatetemp;
  enemyMoveTiming = enemyMoveTimingtemp;
}

 public void update() {
  if (screenIndex != 9) enemyX = enemyX + enemySpeedX; //update enemy x pos according to speed (only if not in level editor
  enemyY = enemyY + enemySpeedY; //update enemy y pos according to speed
  if (enemyHP <= 0) enemyState = 2; //set enemy as dead if hp is zero
  if (enemyState != 2) { //only run if enemy is not dead
    if (enemyTiming < 255) enemyTiming++; //increment enemy timer (used for timing enemy firing
    
    switch(enemyType) {
      case 0:
      enemySpeedY = (sin((enemyMoveTiming / 1)) * 1);
      enemyMoveTiming = enemyMoveTiming + 0.025f;
      break;
      case 4:
      if (screenIndex != 9) { //only run if not in level editor mode
        if (enemyX <= 1000) enemyX = 1000;
        else enemyTiming = 199;
      }
      break;
      default:
      break;
    }
    
    if (enemyX < -200) enemyState = 2; //kill enemy if off screen
    if (enemyType == 7 && screenIndex != 9) { //only do if enemy type is energy weapon and not in level editor
      enemyHP = enemyHP + (enemyHPMax / 1000);
      if (enemyHP > enemyHPMax) enemyHP = enemyHPMax;
      if (enemyX < (900 - (abs(enemyY - 300))/2)) enemySpeedX = 0;
    }
  }
}

 public void collision() {
  for (int i = 0; i < bulletCount; i++) { //run for every bullet instance
   if (blts[i].bulletType != 255 && enemyState != 2) { //check to ensure bullet is not inactive (for efficiency) and enemy is not dead
    if (enemyX - (enemyHitX / 2) <= blts[i].bulletX - (blts[i].bulletHitX / 2)) {
      if ((enemyX + (enemyHitX / 2)) >= (blts[i].bulletX - (blts[i].bulletHitX / 2))) {
        if (enemyY - (enemyHitY / 2) <= blts[i].bulletY - (blts[i].bulletHitY / 2)) {
          if ((enemyY + (enemyHitY / 2)) >= (blts[i].bulletY - (blts[i].bulletHitY / 2))) {
            if (blts[i].bulletType < 199) { //check if bullet type is player projectile
              enemyState = 1; //change enemy to hurt state
              enemyHP = enemyHP - blts[i].bulletPower; //reduce enemy hp per bullet power
              dmg[findDamage()] = new damage(enemyX, enemyY, blts[i].bulletPower, 0, 30);
              if (enemyHP <= 0) {
                enemyTiming = 30; //start timer over for death anim
                enemyState = 2; //set enemy to dead
                playerMoney = playerMoney + (enemyHPMax * moneyValueDrop * moneyBalance); //add money for kill
                playerXP = playerXP + (enemyHPMax * xpValueDrop * xpBalance); //add xp for kill
                checkForLevelUp(); //check if player leveled up
              }
              if (blts[i].bulletType != 4) blts[i].reset(); //reset bullet on impact if not snipe shot
            }
            
          }
        }
      }
    }
  }
  }
}

 public void reset() {
  enemyX = -250;
  enemyY = -250;
  enemySpeedX = 0;
  enemySpeedY = 0;
  enemyType = 255;
  enemyHitX = 0;
  enemyHitY = 0;
  enemyHP = 0;
  enemyHPMax = 0;
  enemyState = 2; //dead
}

 public void shoot() {
  if (screenIndex == 9) displayX = enemyX - scrollX;
   else displayX = enemyX;
   if (enemyState != 2 && displayX < 1250) { //check if enemy is on screen and not dead
    if (enemyType == 0) { //check to see if enemy is a drone
    if (enemyTiming > 40) { //check to make sure enough time has passed since last shot
    float speed = 5; //higher numbers are slower
    int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
    int offsetY = 10; //account for incorrect aim
    float c = sqrt((abs(playerX - displayX + offsetX)) + abs((playerY - enemyY + offsetY))); //solve for hypotenuse
    c = c * speed; //scale c (distance hypotenuse) to speed
    float speedX = (playerX - displayX + offsetX);
    float speedY = (playerY - enemyY + offsetY);
    speedX = speedX / (c);
    speedY = speedY / (c);
    blts[findBullet()] = new bullet(displayX, enemyY, speedX, speedY, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    enemyTiming = 0;
    }
  } else if (enemyType == 1) { //check for enemy type helicopter
    if (enemyTiming > 80) { //check to make sure enough time has passed since last shot
    blts[findBullet()] = new bullet(displayX - 50, enemyY + 13, -5, 0, 200, 50, 5, 10 * enemyBalanceDMG, 0);
    enemyTiming = 0;
    }
  } else if (enemyType == 2) { //check for enemy type small interceptor that shoots a spread shot
    if (enemyTiming > 60) { //check to make sure enough time has passed since last shot
    blts[findBullet()] = new bullet(displayX - 70, enemyY, -5, +1, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    blts[findBullet()] = new bullet(displayX - 70, enemyY, -5, +0.5f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    blts[findBullet()] = new bullet(displayX - 70, enemyY, -5, 0, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    blts[findBullet()] = new bullet(displayX - 70, enemyY, -5, -0.5f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    blts[findBullet()] = new bullet(displayX - 70, enemyY, -5, -1, 200, 10, 10, 10 * enemyBalanceDMG, 0);
    enemyTiming = 0;
    }
    } else if (enemyType == 3) { //check for enemy type medium interceptor
    if (enemyTiming > 30) { //check to make sure enough time has passed since last shot
      blts[findBullet()] = new bullet(displayX - 40, enemyY + 13, -10, 0, 200, 10, 5, 5 * enemyBalanceDMG, 0);
      enemyTiming = 0;
    }
  } else if (enemyType == 4) { //check for enemy type miniboss cargo ship
    if (enemyTiming > 200) { //check to make sure enough time has passed since last shot
    basicE[findEnemy()] = new enemy(PApplet.parseInt(displayX - 80), PApplet.parseInt(enemyY + 15), -2, 0, 5, 50, 50, 50, 50, 0, 0, 0); //i have no idea why the x/y need to be cast as ints but they do
    basicE[findEnemy()] = new enemy(PApplet.parseInt(displayX - 80), PApplet.parseInt(enemyY + 15), -2, -1, 5, 50, 50, 50, 50, 0, 0, 0);
    basicE[findEnemy()] = new enemy(PApplet.parseInt(displayX - 80), PApplet.parseInt(enemyY + 15), -2, 1, 5, 50, 50, 50, 50, 0, 0, 0);
      enemyTiming = 0;
    }
  } else if (enemyType == 5) { //check for enemy type, this is the bomb
    if (enemyTiming > 120) { //check to make sure enough time has passed since last shot
      blts[findBullet()] = new bullet(displayX, enemyY, 0, -4, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, 0, +4, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, +4, 0, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -4, 0, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      
      blts[findBullet()] = new bullet(displayX, enemyY, -2.828f, +2.828f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -2.828f, -2.828f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, +2.828f, +2.828f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, +2.828f, -2.828f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      
      blts[findBullet()] = new bullet(displayX, enemyY, +1.53f, +3.695f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -1.53f, +3.695f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, +1.53f, -3.695f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -1.53f, -3.695f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      
      blts[findBullet()] = new bullet(displayX, enemyY, +3.695f, +1.53f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -3.695f, +1.53f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, +3.695f, -1.53f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      blts[findBullet()] = new bullet(displayX, enemyY, -3.695f, -1.53f, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      
      //destroy bomb
      enemyTiming = 30;
      enemyState = 2;
      enemyHP = 0;
    }
  } else if (enemyType == 6) { //small interceptor that shoots homing shots once it reaches the end of the screen
    if (enemyTiming > 20 && enemyX < 200) {
      float speed = 10; //higher numbers are slower
      int offsetX = 30; //account for incorrect aim, ie these values change the point of aim
      int offsetY = 10; //account for incorrect aim
      float c = sqrt((abs(playerX - enemyX + offsetX)) + abs((playerY - enemyY + offsetY))); //solve for hypotenuse
      c = c * speed; //scale c (distance hypotenuse) to speed
      float speedX = (playerX - enemyX + offsetX);
      float speedY = (playerY - enemyY + offsetY);
      speedX = speedX / (c);
      speedY = speedY / (c);
      blts[findBullet()] = new bullet(displayX, enemyY, speedX, speedY, 200, 10, 10, 10 * enemyBalanceDMG, 0);
      enemyTiming = 0;
    }
  } else if (enemyType == 7) { //energy weapon
    if (enemyTiming > 120) {
      blts[findBullet()] = new bullet(displayX - 140, enemyY, -30, 0, 201, 250, 20, 5 * enemyBalanceDMG, 0);
      enemyTiming = 0;
    }
  }
   }
}

 public void display() {
  displayX = enemyX - scrollX;
  strokeWeight(1);
  noStroke();
  if (enemyState == 1) tint(255, 100, 100);
  if (enemyState != 2) { //do not display hp bar and render enemy if enemy is dead
    if (screenIndex == 9) {
      //draw hp bars
      strokeWeight(1);
      stroke(0);
      fill(20, 255, 20, 100);
      rect(displayX - (enemyHitX * 0.45f), enemyY - (enemyHitY - 5), ((enemyHitX - 5) * (enemyHP / enemyHPMax)), 5);
      
      //draw enemies
      switch(enemyType) {
        case 0: //drone that fires a homing shot
        image(faun1, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 1: //small gunship
        image(faun2, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 2: //small interceptor (spread shot)
        image(faun3, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 3: //medium interceptor
        image(faun4, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 4: //cargo ship
        image(faun5, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 6: //small interceptor that does not fire until it reaches a certain part of the screen, then fires a homing shot
        image(faun3, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 7: //energy weapon that charges
        fill(20, 20, 200, 150);
        stroke(20, 20, 200, 150);
        rect(displayX - (enemyTiming / 2), enemyY - 12, 50, 25); //shooting animation
        image(faun6, displayX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        default:
        noStroke();
        fill(255, 0, 0);
        ellipse(displayX, enemyY, enemyHitX, enemyHitY);
        break;
      }
    } else {
      //draw hp bars
      strokeWeight(1);
      stroke(0);
      fill(20, 255, 20, 100);
      rect(enemyX - (enemyHitX * 0.45f), enemyY - (enemyHitY - 5), ((enemyHitX - 5) * (enemyHP / enemyHPMax)), 5);
      
      //draw enemies
      switch (enemyType) {
        case 0: //drone that fires a homing shot
        image(faun1, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 1: //small gunship
        image(faun2, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 2: //small interceptor (spread shot)
        image(faun3, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 3: //medium interceptor
        image(faun4, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 4: //cargo ship
        image(faun5, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 6: //small interceptor that does not fire until it reaches a certain part of the screen, then fires a homing shot
        image(faun3, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        case 7: //energy weapon that charges
        fill(20, 20, 200, 150);
        stroke(20, 20, 200, 150);
        rect(enemyX - (enemyTiming / 2), enemyY - 12, 50, 25); //shooting animation
        image(faun6, enemyX - (enemyHitX / 2), enemyY - (enemyHitY / 2));
        break;
        default:
        noStroke();
        fill(255, 0, 0);
        ellipse(enemyX, enemyY, enemyHitX, enemyHitY);
        break;
      }
    }
    tint(255, 255, 255); //reset tint
    enemyState = 0; //reset enemy state (so it untints after being shot)
  } else if (enemyState == 2 && enemyTiming !=0) { //death state anim
    fill(255, 127, 0, 100);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 5), (enemyHitY / 2) + (enemyTiming * 3));
    fill(255, 165, 0, 120);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 4), (enemyHitY / 2) + (enemyTiming * 2));
    fill(255, 240, 60, 150);
    ellipse(enemyX, enemyY, (enemyHitX / 3) + (enemyTiming * 3), (enemyHitY / 2) + (enemyTiming * 1));
    enemyTiming--;
  }
  
}
}
 public void loadText() {
  String[] loadScript = loadStrings("assets/text/script.txt");
  levelEndCommands = loadStrings("assets/text/level-end-commands.txt");
  /*String OS = System.getProperty("os.name").toLowerCase();
  if (OS.contains("win")) {//if windows
  //%APPDATA%/edge-of-solaris
    settingsJSON = loadJSONObject("settings.json");
  } else { //if not on windows ie linux
    file = new File("$XDG_DATA_HOME/edge-of-solaris/settings.json");
    if (file.isFile() == true) settingsJSON = loadJSONObject(file); else settingsJSON = loadJSONObject("settings.json"); //if no appdata save default to root
  }*/
  
  file = new File(userDataDir(), "settings.json");
  if (file.isFile() == true) {settingsJSON = loadJSONObject(file); useCWD = true;} else settingsJSON = loadJSONObject("settings.json");
  
  int tempInt = settingsJSON.getInt("oneHitMode");
  if (tempInt == 1) oneHitMode = true; else oneHitMode = false;
  tempInt = settingsJSON.getInt("damageOnTop");
  if (tempInt == 1) damageOnTop = true; else damageOnTop = false;
  
  for(int i = 0; i < loadScript.length; i++) {
    textLines[i] = loadScript[i]; //this is necessary trust me
    scriptLength++;
  }
}

 public String userDataDir() {
  // Default to CWD, allow overriding with '-Dsolaris.dir'
  return System.getProperty("solaris.dir", System.getProperty("user.dir"));
}

 public String[] loadUserDataFile(String name) {
  // Load file in the user data directory, falling back to the one in the sketch
  // directory if it does not exist yet
  final File file = new File(userDataDir(), name);
  return file.isFile() ? loadStrings(file) : loadStrings("gamesave.save");
}

 public void loadSave() { //load the player data save file
  file = new File(userDataDir(), "gamesave.json");
  if (file.isFile() == true) {gamesaveJSON = loadJSONObject(file); useCWD = true;} else gamesaveJSON = loadJSONObject("gamesave.json");
  
  playerHPMax = gamesaveJSON.getFloat("playerHPMax");
  playerShieldMax = gamesaveJSON.getFloat("playerShieldMax");
  playerDefense = gamesaveJSON.getFloat("playerDefense");
  playerAttack = gamesaveJSON.getFloat("playerAttack");
  playerMoney = gamesaveJSON.getFloat("playerMoney");
  playerXP = gamesaveJSON.getFloat("playerXP");
  playerStatPoints = gamesaveJSON.getInt("playerStatPoints");
  playerCooldown = gamesaveJSON.getFloat("playerCooldown");
  playerWeaponLevel0 = gamesaveJSON.getInt("playerWeaponLevel0");
  playerWeaponLevel1 = gamesaveJSON.getInt("playerWeaponLevel1");
  playerWeaponLevel2 = gamesaveJSON.getInt("playerWeaponLevel2");
  playerWeaponLevel4 = gamesaveJSON.getInt("playerWeaponLevel4");
  playerWeaponsUnlocked = gamesaveJSON.getInt("playerWeaponsUnlocked");
  level0Completed = gamesaveJSON.getBoolean("level0Completed");
  level1Completed = gamesaveJSON.getBoolean("level1Completed");
  
  playerLevel = (int)Math.cbrt(playerXP);
}

 public void saveSave() { //save the player data save file
  gamesaveJSON.setFloat("playerHPMax", playerHPMax);
  gamesaveJSON.setFloat("playerShieldMax", playerShieldMax);
  gamesaveJSON.setFloat("playerDefense", playerDefense);
  gamesaveJSON.setFloat("playerAttack", playerAttack);
  gamesaveJSON.setFloat("playerMoney", playerMoney);
  gamesaveJSON.setInt("playerStatPoints", playerStatPoints);
  gamesaveJSON.setFloat("playerCooldown", playerCooldown);
  gamesaveJSON.setInt("playerWeaponLevel0", playerWeaponLevel0);
  gamesaveJSON.setInt("playerWeaponLevel1", playerWeaponLevel1);
  gamesaveJSON.setInt("playerWeaponLevel2", playerWeaponLevel2);
  gamesaveJSON.setInt("playerWeaponLevel4", playerWeaponLevel4);
  gamesaveJSON.setInt("playerWeaponsUnlocked", playerWeaponsUnlocked);
  gamesaveJSON.setBoolean("level0Completed", level0Completed);
  gamesaveJSON.setBoolean("level1Completed", level1Completed);
  
  saveJSONObject(gamesaveJSON, "gamesave.json");
  fill(255);
  textSize(36);
  text("game saved", 975, 675);
}

 public void saveSettings() { //save the settings file
  if (oneHitMode == true) settingsJSON.setInt("oneHitMode", 1); else settingsJSON.setInt("oneHitMode", 0);
  if (damageOnTop == true) settingsJSON.setInt("damageOnTop", 1); else settingsJSON.setInt("damageOnTop", 0);
  
  saveJSONObject(settingsJSON, "settings.json");
}

 public void scanLevelEndCommands() { //scan the level end commands file
  char[] ch = levelEndCommands[levelIndex].toCharArray();
  if (ch[3] == '-' && ch[4] == 'l') { //load level
    commandIndex = (ch[6] - '0') * 10 + (ch[7] - '0'); //read the level index to load
    levelStart(commandIndex); //load the level
  } else if (ch[3] == '-' && ch[4] == 'c') { //load a menu screen
    commandIndex = (ch[6] - '0') * 10 + (ch[7] - '0'); //load the index of the screen
    screenIndex = commandIndex; //jump to that screen
  } else if (ch[3] == '-' && ch[4] == 's') { //load a script segment
    commandIndex = (ch[6] - '0') * 10 + (ch[7] - '0'); //jump to a script text section
    screenIndex = 3; //set screen to vn
    textIndex = scriptStartPoints[commandIndex]; //set the text index to the selected start point
  } else if (ch[3] == '-' && ch[4] == 'a') { //load a new area (jump to level select)
    commandIndex = (ch[6] - '0') * 10 + (ch[7] - '0'); //jump to a script text section
    screenIndex = 2; //set screen to level select
    areaIndex = commandIndex; //set area to selected area
  } else { //fallback
    screenIndex = 2;
  }
}

 public void loadSprites() { //load png assets
  faun1 = loadImage("assets/png/faun/3-xx.png");
  faun2 = loadImage("assets/png/faun/2-xx.png");
  faun3 = loadImage("assets/png/faun/1-xx.png");
  faun4 = loadImage("assets/png/faun/4-xx.png");
  faun5 = loadImage("assets/png/faun/5-xx.png");
  faun6 = loadImage("assets/png/faun/6-xx.png");
  
  player1 = loadImage("assets/png/player/3-x.png");

  vnPlayer1 = loadImage("assets/vn/player/1.png");
  vnPlayer2 = loadImage("assets/vn/player/2.png");
  vnPlayer1r = loadImage("assets/vn/player/1-r.png");
  vnPlayer2r = loadImage("assets/vn/player/2-r.png");
  vnSol1 = loadImage("assets/vn/sol/1.png");
  vnSol2 = loadImage("assets/vn/sol/2.png");
  vnSol3 = loadImage("assets/vn/sol/3.png");

  vnEsence1 = loadImage("assets/vn/esence/1.png");
  vnEsence2 = loadImage("assets/vn/esence/2.png");
  vnEsence3 = loadImage("assets/vn/esence/3.png");
  vnEsence4 = loadImage("assets/vn/esence/4.png");

  vnCyana1 = loadImage("assets/vn/cyana/1.png");
  vnCyana2 = loadImage("assets/vn/cyana/2.png");
  vnCyana3 = loadImage("assets/vn/cyana/3.png");
  vnCyana4 = loadImage("assets/vn/cyana/4.png");
  
  vnVeda1 = loadImage("assets/vn/veda/1.png");
  vnVeda2 = loadImage("assets/vn/veda/2.png");
  vnVeda3 = loadImage("assets/vn/veda/3.png");
  vnVeda4 = loadImage("assets/vn/veda/4.png");

  settingsBtn = loadImage("assets/ui/settings.png");
  shadow = loadImage("assets/ui/shadow.png");
  shadow2 = loadImage("assets/ui/shadow2.png");
  shadow3 = loadImage("assets/ui/shadow3.gif");
  shadow4 = loadImage("assets/ui/shadow4.png");
}
 public void placeEnemies() {
  if (levelIndex == 98) { //performance test level
    genEnemy(2, 1000, 300);
    
    genEnemy(0, 1200, 200);
    genEnemy(0, 1200, 400);
    genEnemy(0, 1200, 100);
    genEnemy(0, 1200, 500);
    genEnemy(0, 1200, 600);
    genEnemy(0, 1200, 0);
    
    genEnemy(3, 1300, 50);
    genEnemy(3, 1300, 225);
    genEnemy(3, 1300, 400);
    genEnemy(3, 1300, 575);
    
    genEnemy(0, 1400, 100);
    genEnemy(0, 1400, 300);
    genEnemy(0, 1400, 500);
    
    genEnemy(1, 1600, 50);
    genEnemy(1, 1600, 225);
    genEnemy(1, 1600, 400);
    genEnemy(1, 1600, 575);
    
    genEnemy(0, 1800, 100);
    genEnemy(0, 1800, 300);
    genEnemy(0, 1800, 500);
    
    genEnemy(3, 2000, 50);
    genEnemy(3, 2000, 225);
    genEnemy(3, 2000, 400);
    genEnemy(3, 2000, 575);
    
    genEnemy(1, 2200, 100);
    genEnemy(2, 2200, 300);
    genEnemy(1, 2200, 500);
    
    genEnemy(0, 2400, 50);
    genEnemy(0, 2400, 225);
    genEnemy(0, 2400, 400);
    genEnemy(0, 2400, 575);
    
    genEnemy(4, 3000, 50);
    genEnemy(4, 3000, 150);
    genEnemy(4, 3000, 250);
    genEnemy(4, 3000, 350);
    genEnemy(4, 3000, 450);
    genEnemy(4, 3000, 550);
    
    genEnemy(0, 3600, 0);
    genEnemy(0, 3600, 100);
    genEnemy(0, 3600, 200);
    genEnemy(0, 3600, 300);
    genEnemy(0, 3600, 400);
    genEnemy(0, 3600, 500);
    genEnemy(0, 3600, 600);
    
    genEnemy(0, 3700, 0);
    genEnemy(0, 3700, 100);
    genEnemy(0, 3700, 200);
    genEnemy(0, 3700, 300);
    genEnemy(0, 3700, 400);
    genEnemy(0, 3700, 500);
    genEnemy(0, 3700, 600);
    
    genEnemy(0, 3800, 0);
    genEnemy(0, 3800, 100);
    genEnemy(0, 3800, 200);
    genEnemy(0, 3800, 300);
    genEnemy(0, 3800, 400);
    genEnemy(0, 3800, 500);
    genEnemy(0, 3800, 600);
    
    genEnemy(0, 3900, 0);
    genEnemy(0, 3900, 100);
    genEnemy(0, 3900, 200);
    genEnemy(0, 3900, 300);
    genEnemy(0, 3900, 400);
    genEnemy(0, 3900, 500);
    genEnemy(0, 3900, 600);
    
    genEnemy(0, 4000, 0);
    genEnemy(0, 4000, 100);
    genEnemy(0, 4000, 200);
    genEnemy(0, 4000, 300);
    genEnemy(0, 4000, 400);
    genEnemy(0, 4000, 500);
    genEnemy(0, 4000, 600);
    
    genEnemy(0, 4100, 0);
    genEnemy(0, 4100, 100);
    genEnemy(0, 4100, 200);
    genEnemy(0, 4100, 300);
    genEnemy(0, 4100, 400);
    genEnemy(0, 4100, 500);
    genEnemy(0, 4100, 600);
    
    genEnemy(0, 4200, 0);
    genEnemy(0, 4200, 100);
    genEnemy(0, 4200, 200);
    genEnemy(0, 4200, 300);
    genEnemy(0, 4200, 400);
    genEnemy(0, 4200, 500);
    genEnemy(0, 4200, 600);
    
    genEnemy(0, 4300, 0);
    genEnemy(0, 4300, 100);
    genEnemy(0, 4300, 200);
    genEnemy(0, 4300, 300);
    genEnemy(0, 4300, 400);
    genEnemy(0, 4300, 500);
    genEnemy(0, 4300, 600);
    
    genEnemy(0, 4400, 0);
    genEnemy(0, 4400, 100);
    genEnemy(0, 4400, 200);
    genEnemy(0, 4400, 300);
    genEnemy(0, 4400, 400);
    genEnemy(0, 4400, 500);
    genEnemy(0, 4400, 600);
    
    genEnemy(0, 4500, 0);
    genEnemy(0, 4500, 100);
    genEnemy(0, 4500, 200);
    genEnemy(0, 4500, 300);
    genEnemy(0, 4500, 400);
    genEnemy(0, 4500, 500);
    genEnemy(0, 4500, 600);
    
    genEnemy(0, 4600, 0);
    genEnemy(0, 4600, 100);
    genEnemy(0, 4600, 200);
    genEnemy(0, 4600, 300);
    genEnemy(0, 4600, 400);
    genEnemy(0, 4600, 500);
    genEnemy(0, 4600, 600);
    
    genEnemy(0, 4700, 0);
    genEnemy(0, 4700, 100);
    genEnemy(0, 4700, 200);
    genEnemy(0, 4700, 300);
    genEnemy(0, 4700, 400);
    genEnemy(0, 4700, 500);
    genEnemy(0, 4700, 600);
    
    genEnemy(0, 4800, 0);
    genEnemy(0, 4800, 100);
    genEnemy(0, 4800, 200);
    genEnemy(0, 4800, 300);
    genEnemy(0, 4800, 400);
    genEnemy(0, 4800, 500);
    genEnemy(0, 4800, 600);
  } else if (levelIndex == 1) { //miniboss level
    genEnemy(6, 1000, 350);
    genEnemy(6, 800, 150);
    genEnemy(6, 800, 550);
    
    genEnemy(0, 1400, 350);
    genEnemy(0, 1400, 500);
    genEnemy(0, 1400, 200);
    
    genEnemy(3, 1700, 350);
    genEnemy(3, 1750, 400);
    genEnemy(3, 1750, 300);
    genEnemy(3, 1800, 450);
    genEnemy(3, 1800, 250);
    
    genEnemy(6, 2000, 450);
    genEnemy(6, 2050, 500);
    genEnemy(6, 2100, 550);
    
    genEnemy(6, 2200, 250);
    genEnemy(6, 2250, 200);
    genEnemy(6, 2300, 150);
    
    genEnemy(4, 2500, 300);
  } else if (levelIndex == 0) { //opening level
    genEnemy(6, 1000, 400);
    genEnemy(6, 1100, 500);
    genEnemy(6, 1200, 600);
    genEnemy(6, 1500, 300);
    genEnemy(6, 1600, 200);
    genEnemy(6, 1700, 100);
    
    genEnemy(6, 2100, 350);
    genEnemy(6, 2200, 450);
    genEnemy(6, 2200, 250);
    genEnemy(6, 2300, 550);
    genEnemy(6, 2300, 150);
    
    genEnemy(6, 2800, 350);
    genEnemy(6, 2850, 400);
    genEnemy(6, 2850, 300);
    genEnemy(6, 2900, 450);
    genEnemy(6, 2900, 250);
    genEnemy(6, 2950, 500);
    genEnemy(6, 2950, 200);
    genEnemy(6, 3000, 550);
    genEnemy(6, 3000, 150);
    
    genEnemy(6, 3200, 350);
    genEnemy(6, 3300, 450);
    genEnemy(6, 3300, 250);
    genEnemy(6, 3400, 550);
    genEnemy(6, 3400, 150);
    
    genEnemy(6, 3600, 350);
    genEnemy(6, 3650, 400);
    genEnemy(6, 3650, 300);
    genEnemy(6, 3700, 450);
    genEnemy(6, 3700, 250);
    genEnemy(6, 3750, 500);
    genEnemy(6, 3750, 200);
    genEnemy(6, 3800, 550);
    genEnemy(6, 3800, 150);
  } else if (levelIndex == 99) {
    genEnemy(7, 900, 100);
    genEnemy(7, 900, 200);
    genEnemy(7, 900, 300);
    genEnemy(7, 900, 400);
    genEnemy(7, 900, 500);
    genEnemy(7, 900, 600);
  } else if (levelIndex == 2) { //3rd level
    genEnemy(2, 900, 100);
    genEnemy(2, 1100, 300);
    genEnemy(2, 1300, 500);
    
    genEnemy(2, 1600, 500);
    genEnemy(2, 1800, 300);
    genEnemy(2, 2000, 100);
    
    genEnemy(2, 2600, 100);
    genEnemy(2, 2650, 200);
    genEnemy(2, 2600, 300);
    genEnemy(2, 2650, 400);
    genEnemy(2, 2600, 500);
    
    genEnemy(2, 3200, 50);
    genEnemy(2, 3250, 150);
    genEnemy(2, 3200, 250);
    genEnemy(2, 3250, 350);
    genEnemy(2, 3200, 450);
    genEnemy(2, 3250, 550);
    genEnemy(0, 3200, 600);
    
    genEnemy(2, 3600, 100);
    genEnemy(2, 3650, 200);
    genEnemy(2, 3600, 300);
    genEnemy(2, 3650, 400);
    genEnemy(2, 3600, 500);
    
    genEnemy(2, 4200, 500);
    genEnemy(2, 4200, 300);
    genEnemy(2, 4200, 100);
    
    genEnemy(2, 4600, 500);
    genEnemy(2, 4600, 300);
    genEnemy(2, 4600, 100);
    
    genEnemy(2, 5000, 500);
    genEnemy(2, 5000, 300);
    genEnemy(2, 5000, 100);
    
    genEnemy(2, 5600, 100);
    genEnemy(2, 5650, 200);
    genEnemy(2, 5600, 300);
    genEnemy(2, 5650, 400);
    genEnemy(2, 5600, 500);
    genEnemy(0, 5600, 600);
    
    genEnemy(2, 6200, 50);
    genEnemy(2, 6250, 150);
    genEnemy(2, 6200, 250);
    genEnemy(2, 6250, 350);
    genEnemy(2, 6200, 450);
    genEnemy(2, 6250, 550);
    
    genEnemy(2, 6600, 100);
    genEnemy(2, 6650, 200);
    genEnemy(2, 6600, 300);
    genEnemy(2, 6650, 400);
    genEnemy(2, 6600, 500);
    genEnemy(0, 6600, 600);
    
    genEnemy(0, 7200, 500);
    genEnemy(0, 7200, 300);
    genEnemy(0, 7200, 100);
    
    genEnemy(0, 7600, 500);
    genEnemy(0, 7600, 300);
    genEnemy(0, 7600, 100);
    
    genEnemy(0, 8000, 500);
    genEnemy(0, 8000, 300);
    genEnemy(0, 8000, 100);
    
    genEnemy(1, 8600, 100);
    genEnemy(1, 8650, 200);
    genEnemy(1, 8600, 300);
    genEnemy(1, 8650, 400);
    genEnemy(1, 8600, 500);
  }
}

 public void genEnemy(int type, int x, int y) { //used for placing enemies easier, pass in enemy type and position x/y
  enemyIndex = findEnemy();
  basicE[enemyIndex].enemyState = 0;
  if (type == 0) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = 0;
    basicE[enemyIndex].enemyHitX = 110;
    basicE[enemyIndex].enemyHitY = 110;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 1) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 210;
    basicE[enemyIndex].enemyHitY = 86;
    basicE[enemyIndex].enemyHP = 30 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 30 * enemyBalanceHP;
  } else if (type == 2) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 170;
    basicE[enemyIndex].enemyHitY = 70;
    basicE[enemyIndex].enemyHP = 40 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 40 * enemyBalanceHP;
  } else if (type == 3) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 190;
    basicE[enemyIndex].enemyHitY = 58;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 4) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 252;
    basicE[enemyIndex].enemyHitY = 102;
    basicE[enemyIndex].enemyHP = 100 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 100 * enemyBalanceHP;
  } else if (type == 6) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 170;
    basicE[enemyIndex].enemyHitY = 70;
    basicE[enemyIndex].enemyHP = 10 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 10 * enemyBalanceHP;
  } else if (type == 7) {
    basicE[enemyIndex].enemyX = x;
    basicE[enemyIndex].enemyY = y;
    basicE[enemyIndex].enemySpeedX = autoScroll;
    basicE[enemyIndex].enemySpeedY = 0;
    basicE[enemyIndex].enemyType = type;
    basicE[enemyIndex].enemyHitX = 120;
    basicE[enemyIndex].enemyHitY = 52;
    basicE[enemyIndex].enemyHP = 20 * enemyBalanceHP;
    basicE[enemyIndex].enemyHPMax = 20 * enemyBalanceHP;
  }
}

 public void levelEditor() { //the level editor routine is here
  //render background
  if (levelType == 1) background(180, 248, 255);
     else if (levelType == 2) background(0);
     
  //render stars/clouds
  if (levelType == 2 || levelType == 1) {
    for (starsBG stars : stars) {
      stars.update();
      stars.display();
    }
  }
    
  //render and process enemies (enemies will fire once placed)
  for (enemy basicE : basicE) {
    basicE.update();
    basicE.shoot();
    basicE.display();
  }
    
  //render and process bullets
  for (bullet blts : blts) {
    blts.update();
    blts.display();
  }
    
  //render player hp and shield bars
  stroke(0);
  strokeWeight(15);
  fill(0);
  rect(20, 650, 200, 50, 10);
  rect(235, 650, 200, 50, 10);
  setRect(4);
  if (playerHP >= 0) rect(23, 653.5f, (195 * (playerHP / playerHPMax)), 44);
  setRect(5);
  rect(238, 653.5f, (194 * (playerShield / playerShieldMax)), 44);
  setRect(3); //render surrounds
  noFill();
  rect(20, 650, 200, 50, 10);
  rect(235, 650, 200, 50, 10);
  fill(0);
    
    
  //render weapon selector
  stroke(255);
  strokeWeight(2);
  rect(450, 653, 30, 20, 5);
  rect(450, 678, 30, 20, 5);
  rect(485, 653, 30, 20, 5);
  rect(485, 678, 30, 20, 5);      
    
  image(player1, playerX - 5 - scrollX, playerY - 5); //player sprite
    
  textSize(24);
  fill(255, 20, 20);
  text("scrollX: " + scrollX, 1000, 25);
  text("mouseX: " + mouseX, 1000, 50);
  text("mouseY: " + mouseY, 1000, 75);
  text("enemyType: " + levelEnemyTypeSelected, 1000, 100);
  text("::CONTROLS::", 1000, 125);
  text("LMB = place enemy", 1000, 150);
  text("MMB = reset enemies", 1000, 175);
  text("RMB = undo", 1000, 200);
  text("A/D scroll", 1000, 225);
  text("W/S fast scroll", 1000, 250);
  text("SPACE cycles enemy type", 1000, 275);
  text("P saves to level-editor-save.json", 950, 300);
  text("M exits to level select", 1000, 325);
  text("L loads the save file", 1000, 350);
  text("T tests the level", 1000, 375);
}

 public void saveLevel() { //saves the level editor level
  levelEditorSaveJSON = new JSONArray();
  for(int i = 0; i < levelEnemyIndex; i++) { //repeat for all 
    JSONObject data = new JSONObject();
    data.setInt("id", i);
    data.setInt("enemyType", levelEnemyType[i]);
    data.setInt("enemyX", levelEnemyX[i]);
    data.setInt("enemyY", levelEnemyY[i]);
    levelEditorSaveJSON.setJSONObject(i, data);
  }
  saveJSONArray(levelEditorSaveJSON, "level-editor-save.json");
  text("saved to level-editor-save.json", 1000, 250);
}

 public void loadLevel() { //load a saved level editor level
  levelEditorSaveJSON = loadJSONArray("level-editor-save.json"); //load the array
  //JSONArray values = levelEditorSaveJSON.getJSONArray(0);
  levelEnemyIndex = 0; //reset the index
  for (int i = 0; i < levelEditorSaveJSON.size(); i++) {
    JSONObject item = levelEditorSaveJSON.getJSONObject(i);
    levelEnemyType[i] = item.getInt("enemyType");
    levelEnemyX[i] = item.getInt("enemyX");
    levelEnemyY[i] = item.getInt("enemyY");
    levelEnemyIndex++;
  }
  
  //redraw enemies
  initObjects(); //reset all enemies
  for(int i = 0; i < levelEnemyIndex; i++) {
        genEnemy(levelEnemyType[i], levelEnemyX[i], levelEnemyY[i]);
  }
}
 public void processInput() {
  if (screenIndex == 0 && paused == false) { //in game and not paused
      if (mousePressed && (mouseButton == LEFT)) { //shoot with LMB
        playerShoot();
      }
      if (keyInput[0] == true) { //w
      if (playerY > 10)
        playerY = playerY - (playerMoveY * playerMoveBoost);
      }
      if (keyInput[1] == true) { //s
      if (playerY < 600)
        playerY = playerY + (playerMoveY * playerMoveBoost);
      }
      if (keyInput[2] == true) { //d
      if (playerX < 1200)
        playerX = playerX + (playerMoveX * playerMoveBoost);
      }
      if (keyInput[3] == true) { //a
      if (playerX > 20)
        playerX = playerX - (playerMoveX * playerMoveBoost);
      }
      if (keyInput[4] == true) { //space
        playerShoot();
      }
      if (keyInput[5] == true && playerWeaponsUnlocked >= 1) { //q, mg weapon
        playerWeapon = 0;
      }
      if (keyInput[6] == true && playerWeaponsUnlocked >= 2) { //e, snipe weapon
        playerWeapon = 4;
      }
      if (keyInput[7] == true && playerWeaponsUnlocked >= 3) { //r, spread weapon
        playerWeapon = 1;
      }
      if (keyInput[8] == true) { //p, pause game
        paused = true;
        keyInput[8] = false;
      }
      if (keyInput[9] == true) { //z, secondary weapon 1
        playerSecondWeapon = 0;
      }
      if (keyInput[10] == true) { //x secondary weapon 2
        playerSecondWeapon = 1;
      }
      if (keyInput[11] == true) { //1, beam cannon primary weapon
        playerWeapon = 2;
      }
      if (keyInput[12] == true && playerWeaponsUnlocked >= 1) { //2, mg primary weapon
        playerWeapon = 0;
      }
      if (keyInput[13] == true && playerWeaponsUnlocked >= 2) { //3, snipe primary weapon
        playerWeapon = 4;
      }
      if (keyInput[14] == true && playerWeaponsUnlocked >= 3) { //4, spread primary weapon
        playerWeapon = 1;
      }
  } else if (screenIndex == 0 && paused == true && levelEnd == false) { //if game is paused and level is not complete
        if (playerState != 255) { //check to ensure player is not dead
          if (keyInput[8] == true) { //p key
            paused = false;
            keyInput[8] = false;
          } 
        } else {
          if (keyInput[7] == true || keyInput[4] == true) { //r key or space key
            levelStart(levelIndex); //restart the current level
            paused = false;
            keyInput[4] = false; //unset space key
          } else if (keyInput[5] == true) { //q key
            //TODO LEVEL EXIT HERE
          }
        }
        
  } else if (screenIndex == 1) {
    if (keyInput[4] == true) screenIndex = 2;
  } else if (screenIndex == 2) {
  
  } else if (screenIndex == 3) {
    if (keyInput[4] == true) {
      advanceVNText();
    }
  } else if (screenIndex == 9) { //level editor
    if (keyInput[2] == true) scrollX++;
    if (keyInput[0] == true) scrollX = scrollX + 10;
    if (keyInput[3] == true) scrollX--;
    if (keyInput[1] == true) scrollX = scrollX - 10;
    if (scrollX < 0) scrollX = 0; //dont let scroll go negative
    if (keyInput[4] == true) {levelEnemyTypeSelected++; keyInput[4] = false;} //press space to cycle enemies
    if (levelEnemyTypeSelected > 7) levelEnemyTypeSelected = 0; //reset it overflow
    if (keyInput[8] == true) saveLevel(); //save the level to a JSON
    if (keyInput[17] == true) screenIndex = 2; //go back to level select
    if (keyInput[18] == true) loadLevel(); //try to load the editor save
    if (keyInput[19] == true) { //playtest level
      println("test");
      screenIndex = 0;
      levelEditorMode = true;
      //redraw enemies
      initObjects(); //reset all enemies
      for(int i = 0; i < levelEnemyIndex; i++) {
        genEnemy(levelEnemyType[i], levelEnemyX[i], levelEnemyY[i]);
      }
    }
  }
}

 public void keyPressed() {
  if (key == 'w' || key == 'W')  keyInput[0] = true;
  if (key == 's' || key == 'S')  keyInput[1] = true;
  if (key == 'd' || key == 'D')  keyInput[2] = true;
  if (key == 'a' || key == 'A')  keyInput[3] = true;
  if (key == ' ') keyInput[4] = true;
  if (key == 'q' || key == 'Q')  keyInput[5] = true;
  if (key == 'e' || key == 'E')  keyInput[6] = true;
  if (key == 'r' || key == 'R')  keyInput[7] = true;
  if (key == 'p' || key == 'P')  keyInput[8] = true;
  if (key == 'z' || key == 'Z')  keyInput[9] = true;
  if (key == 'x' || key == 'X')  keyInput[10] = true;
  if (key == '1') keyInput[11] = true;
  if (key == '2') keyInput[12] = true;
  if (key == '3') keyInput[13] = true;
  if (key == '4') keyInput[14] = true;
  if (key == '5') keyInput[15] = true;
  if (key == '6') keyInput[16] = true;
  if (key == 'm' || key == 'M') keyInput[17] = true;
  if (key == 'l' || key == 'L') keyInput[18] = true;
  if (key == 't' || key == 'T') keyInput[19] = true;
}

 public void keyReleased() {
  if (key == 'w' || key == 'W')  keyInput[0] = false;
  if (key == 's' || key == 'S')  keyInput[1] = false;
  if (key == 'd' || key == 'D')  keyInput[2] = false;
  if (key == 'a' || key == 'A')  keyInput[3] = false;
  if (key == ' ') keyInput[4] = false;
  if (key == 'q' || key == 'Q')  keyInput[5] = false;
  if (key == 'e' || key == 'E')  keyInput[6] = false;
  if (key == 'r' || key == 'R')  keyInput[7] = false;
  if (key == 'p' || key == 'P')  keyInput[8] = false;
  if (key == 'z' || key == 'Z')  keyInput[9] = false;
  if (key == 'x' || key == 'X')  keyInput[10] = false;
  if (key == '1') keyInput[11] = false;
  if (key == '2') keyInput[12] = false;
  if (key == '3') keyInput[13] = false;
  if (key == '4') keyInput[14] = false;
  if (key == '5') keyInput[15] = false;
  if (key == '6') keyInput[16] = false;
  if (key == 'm' || key == 'M') keyInput[17] = false;
  if (key == 'l' || key == 'L') keyInput[18] = false;
  if (key == 't' || key == 'T') keyInput[19] = false;
}

 public void playerShoot() {
  if (playerWeapon == 0) { //machine gun
    if (timing > playerWeaponCooldown0) {
      playerWeaponMove0 = random(2) - 1;
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, playerWeaponMove0, playerWeapon, 10, 10, playerWeaponPower0 * playerAttack, 0);
      timing = 0;
    }
  } else if (playerWeapon == 1) { //spread shot
    if (timing > playerWeaponCooldown1) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 10, 0, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY + 0.2f, 10, 0.2f, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY + 0.4f, 10, 0.5f, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY - 0.2f, 10, -0.2f, playerWeapon, 10, 10, playerWeaponPower1 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY - 0.4f, 10, -0.5f , playerWeapon, 10, 10, playerWeaponPower1 * playerAttack, 0);
      timing = 0;
    }
  } else if (playerWeapon == 2) { //dual beam cannon
      if (timing > playerWeaponCooldown2) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY + 7, 20, 0, playerWeapon, 80, 10, playerWeaponPower2 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY - 7, 20, 0, playerWeapon, 80, 10, playerWeaponPower2 * playerAttack, 0);
      timing = 0;
    }
  } else if (playerWeapon == 4) { //sniper shot
      if (timing > playerWeaponCooldown4) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 50, 0, playerWeapon, 200, 10, playerWeaponPower4 * playerAttack, 0);
      timing = 0;
    }
  }
  if (playerSecondWeapon == 0) { //basic secondary rockets
    if (secondTiming > playerWeaponCooldown100) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, -10, +10, playerSecondWeapon + 100, 20, 10, playerWeaponPower100 * playerAttack, 0);
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, -10, -10, playerSecondWeapon + 100, 20, 10, playerWeaponPower100 * playerAttack, 0);
      secondTiming = 0;
    }
  } else if (playerSecondWeapon == 1) { //tracking missile
    if (secondTiming > playerWeaponCooldown101) {
      blts[findBullet()] = new bullet(playerX + playerBulletOffsetX, playerY + playerBulletOffsetY, 5, 0, playerSecondWeapon + 100, 10, 10, playerWeaponPower101 * playerAttack, 0);
      secondTiming = 0;
    }
  }
}

 public void mousePressed() {
  if (screenIndex == 2) {//menu screen
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) screenIndex = 5; //status button
    else if (mouseX > 950 && mouseX < 1250 && mouseY > 125 && mouseY < 200); //mess hall button
    else if (mouseX > 950 && mouseX < 1250 && mouseY > 225 && mouseY < 300); //hanger button
    else if (mouseX > 950 && mouseX < 1250 && mouseY > 325 && mouseY < 400) screenIndex = 8; //engineering buttton
    else if (mouseX > 950 && mouseX < 1250 && mouseY > 425 && mouseY < 500) screenIndex = 4; //settings button 
    else if (mouseX > 950 && mouseX < 1250 && mouseY > 525 && mouseY < 600) saveSave(); //save button 
    if (areaIndex == 0) { //debug area
      if (mouseX > 50 && mouseX < 750 && mouseY > 25 && mouseY < 100) {screenIndex = 3;textIndex = scriptStartPoints[0];} //story button
      else if (mouseX > 50 && mouseX < 750 && mouseY > 125 && mouseY < 200) levelStart(0); //level 00
      else if (mouseX > 50 && mouseX < 750 && mouseY > 225 && mouseY < 300) levelStart(1); //level 01
      else if (mouseX > 50 && mouseX < 750 && mouseY > 325 && mouseY < 400) levelStart(98); //performance test level
      else if (mouseX > 50 && mouseX < 750 && mouseY > 425 && mouseY < 500) levelStart(99); //performance test level 2
    } else if (areaIndex == 1) { //first area
      if (mouseX > 50 && mouseX < 750 && mouseY > 25 && mouseY < 100) {screenIndex = 3;textIndex = scriptStartPoints[0];} //story button
      if (mouseX > 50 && mouseX < 750 && mouseY > 325 && mouseY < 400) {screenIndex = 9; initObjects();} //level editor button
      if (mouseX > 50 && mouseX < 750 && mouseY > 425 && mouseY < 500) areaIndex = 0; //debug button
    }
  } else if (screenIndex == 3) { //vn segments
    if (mouseX > 1150 && mouseX < 1250 && mouseY > 650 && mouseY < 690) { //next button
      advanceVNText();
    }
    else if (mouseX > 1040 && mouseX < 1140 && mouseY > 650 && mouseY < 690); //skip button (currently doesnt do anything
  } else if (screenIndex == 4) { //settings menu
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) {screenIndex = 2; saveSettings();} //back button (also saves settings)
    else if (mouseX > 50 && mouseX < 450 && mouseY > 25 && mouseY < 100) oneHitMode = !oneHitMode; //pause on restart button
    else if (mouseX > 50 && mouseX < 450 && mouseY > 225 && mouseY < 300) {image(shadow, 500, 500); image(shadow2, 1000, 500); image(shadow3, 500, 200); shadowFactor++;} //shadow
    else if (mouseX > 50 && mouseX < 450 && mouseY > 125 && mouseY < 200) damageOnTop = !damageOnTop; //damage on top button
  } else if (screenIndex == 5) { //stats menu
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) screenIndex = 2; //back button
    else if (mouseX > 625 && mouseX < 700 && mouseY > 125 && mouseY < 200) if (playerStatPoints > 0) {playerHPMax = playerHPMax * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 225 && mouseY < 300) if (playerStatPoints > 0) {playerShieldMax = playerShieldMax * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 325 && mouseY < 400) if (playerStatPoints > 0) {playerDefense = playerDefense * 1.05f; playerStatPoints--;}
    if (mouseX > 625 && mouseX < 700 && mouseY > 425 && mouseY < 500) if (playerStatPoints > 0) {playerAttack = playerAttack * 1.05f; playerStatPoints--;}
  } else if (screenIndex == 8) { //engineering menu
    if (mouseX > 950 && mouseX < 1250 && mouseY > 25 && mouseY < 100) if (areaIndex == 2) {screenIndex = 3; textIndex = scriptStartPoints[3];} else screenIndex = 2; //back button
    else if (mouseX > 60 && mouseX < 445 && mouseY > 170 && mouseY < 195 && playerMoney >= playerWeaponCost2) {playerMoney = playerMoney - playerWeaponCost2; playerWeaponLevel2++; calcWeaponStats();} //upgrade beam weapon
    else if (mouseX > 60 && mouseX < 445 && mouseY > 370 && mouseY < 395 && playerMoney >= playerWeaponCost0) {playerMoney = playerMoney - playerWeaponCost0; playerWeaponLevel0++; calcWeaponStats();} //upgrade mg weapon
    else if (mouseX > 60 && mouseX < 445 && mouseY > 570 && mouseY < 595 && playerMoney >= playerWeaponCost4) {playerMoney = playerMoney - playerWeaponCost4; playerWeaponLevel4++; calcWeaponStats();} //upgrade snipe weapon
    else if (mouseX > 485 && mouseX < 870 && mouseY > 170 && mouseY < 195 && playerMoney >= playerWeaponCost1) {playerMoney = playerMoney - playerWeaponCost1; playerWeaponLevel1++; calcWeaponStats();} //upgrade shotgun weapon
  } else if (screenIndex == 9) { //level editor
    //place an enemy
    if (mouseButton == LEFT) { //only place if LMB pressed
      genEnemy(levelEnemyTypeSelected, mouseX + scrollX, mouseY);
      levelEnemyType[levelEnemyIndex] = levelEnemyTypeSelected;
      levelEnemyX[levelEnemyIndex] = mouseX + scrollX;
      levelEnemyY[levelEnemyIndex] = mouseY;
      levelEnemyIndex++;
    } else if (mouseButton == RIGHT) { //undo
      if (levelEnemyIndex > 0) levelEnemyIndex--;
      //redraw enemies
      initObjects(); //reset all enemies
      for(int i = 0; i < levelEnemyIndex; i++) {
        genEnemy(levelEnemyType[i], levelEnemyX[i], levelEnemyY[i]);
      }
    } else if (mouseButton == CENTER) { //reset enemies
      initObjects(); //reset all enemies
      for(int i = 0; i < levelEnemyIndex; i++) {
        genEnemy(levelEnemyType[i], levelEnemyX[i], levelEnemyY[i]);
      }
    }
  }
}
class starsBG {
  int starX;
  int starY;
  int starSpeedX;
  int starSpeedY;

starsBG(int starXtemp, int starYtemp, int starSpeedXtemp, int starSpeedYtemp) {
  starX = starXtemp;
  starY = starYtemp;
  starSpeedX = starSpeedXtemp;
  starSpeedY = starSpeedYtemp;
}

 public void update() {
  starX = starX + starSpeedX;
  starY = starY + starSpeedY;
  if (starX < 0) {
    starY = PApplet.parseInt(random(screenY));
    starX = screenX + 20;
    starSpeedX = PApplet.parseInt(-1 * (random(10) + 1));
  }
}

 public void reset() {
  starX = -200;
  starY = -200;
  starSpeedX = 0;
  starSpeedY = 0;
}

 public void display() {
  if (levelType == 0) {
  } else if (levelType == 1) {
    strokeWeight(5);
    stroke(255, 25);
    fill(255, (150 + (starSpeedX * 10)));
    ellipse(starX, starY, 60, 25);
  } else if (levelType == 2) {
    strokeWeight(5);
    stroke(255, 25);
    fill(255, (150 + (starSpeedX * 10)));
    ellipse(starX, starY, 5, 5);
  }
}
}
//game vars
int buildNumber = 105; //the current build number, should be incremented manually each commit
int screenIndex = 2; //0 = game, 1 = title, 2 = level select, 3 = visual novel story stuff, 4 = settings menu, 5 = status, 6 = mess hall
//7 = hanger, 8 = engineering, 9 = level editor
int levelIndex = 0; //what level the player is playing, 98/99 is test level
int levelType = 1; //0 = over land, 1 = over water, 2 = space
int areaIndex = 1; //tells the level select what options to have, 0 is debug
int enemyIndex = 0; //used for enemy gen
int bulletCount = 500; //total bullet objects
int basicECount = 300; //total enemy objects
int dmgCount = 200; //total damage (readout) objects
int starCount = 100; //how many stars to display
int timing = 0; //used for various timings, namely the players weapon firing timer
int secondTiming = 0; //used for timing secondary weapons
int screenX = 1280; //screen size x
int screenY = 720; //screen size y
float autoScroll = -2; //controls how fast the enemies move to the left
float enemyBalanceHP = 2; //multiplier for enemy hp
float enemyBalanceDMG = 2; //multiplier for enemy shot power
float enemyBalanceBump = 3; //multipler for damage to deal when player bumps into an enemy, it is enemyHP * this multiplier
float moneyBalance = 1; //multiplier for balancing money gained from enemies
float xpBalance = 0.1f; //multiplier for balancing xp gained from enemies
boolean paused = false; //if gameplay is paused this is true
File file; //file used for loading files
boolean useCWD = false; //whether or not to use CWD for file loading/saving (linux only)
int levelEndCheckTimer = 0; //timer to check periodically to see if all enemies are dead
boolean levelEnd = false; //true when on the level end screen
int shadowFactor = 0; //don't ask
boolean level0Completed; //if level0 has been completed or not
boolean level1Completed; //if level1 has been completed or not

//player var
float playerX = 200; //player x pos
float playerY = 250; //player y pos
int playerHitX = 60; //player x hitbox
int playerHitY = 14; //player y hitbox
int playerBulletOffsetX = 45; //offset for where bullet is generated relative to player model
int playerBulletOffsetY = 13; //offset for where bullet is generated relative to player model
int playerMoveX = 4; //player move speed x
int playerMoveY = 4; //player move speed y
int playerWeapon = 2; //player weapon selected
int playerSecondWeapon = 0; //0 = basic missiles
int playerState = 0; //0 = normal, 1-10 = hurt anim, 255 = dead
int playerAnimTiming = 0; //used for the death anim
int bulletIndex = 0; //used for indexing bullets

float playerShield = 0; //current shield
float playerShieldMax = 50; //max shield
float playerShieldRegen = 0.5f; //shield regen per frame
float playerShieldRegenBoost = 1;//percentage boost for regen
float playerHP = 100; //current hp
float playerHPMax = 100; //max hp
float playerDefense = 1.1f; //percentage damage reduction, goes down
float playerDMGReduction = 1; //calculated from playerDefense
float playerAttack = 1; //percentage boost to all player wpn dmg
float playerCooldown = 1; //percentage boost to all wpn cooldown
float enemyDrop = 1; //percentage of time enemies drop items
float moneyValueDrop = 1; //percentage boost of money dropped
float hpValueDrop = 1; //percentage boost of hp dropped
float xpValueDrop = 1; //percentage boost of xp dropped
float playerMoveBoost = 1; //boost to player speed
float playerXP; //amount of xp player has
int playerLevel; //level of player
float playerMoney; //amount of money player has
int playerStatPoints; //stat points to allocate
int playerWeaponsUnlocked; //how many weapons have been unlocked 0-3


//player weapon vars
//machine gun
int playerWeaponCooldown0 = 2;
float playerWeaponPower0;
float playerWeaponBasePower0 = 0.5f;
int playerWeaponHitX0 = 10;
int playerWeaponHitY0 = 10;
float playerWeaponMove0 = 0;
int playerWeaponLevel0;
int playerWeaponCost0;
//spread shot
int playerWeaponCooldown1 = 30;
float playerWeaponPower1;
float playerWeaponBasePower1 = 12;
int playerWeaponLevel1;
int playerWeaponCost1;
//dual beam cannon
int playerWeaponCooldown2 = 20;
float playerWeaponPower2;
float playerWeaponBasePower2 = 5;
int playerWeaponLevel2;
int playerWeaponCost2;
//snipe shot
int playerWeaponCooldown4 = 30;
float playerWeaponPower4;
float playerWeaponBasePower4 = 5;
int playerWeaponLevel4;
int playerWeaponCost4;
//basic secondary rocket
int playerWeaponCooldown100 = 40;
float playerWeaponPower100 = 10;
float playerWeaponBasePower100 = 10;
int playerWeaponLevel100;
//tracking missile
int playerWeaponCooldown101 = 40;
float playerWeaponPower101 = 10;
float playerWeaponBasePower101 = 10;
int playerWeaponLevel101;

//input vars
boolean keyInput[] = new boolean [45];

//visual novel vars
int eventIndex = 0; //index value for events (1 indexed for ease of text editor use)
int textIndex = 2; //index value for which line of dialogue should be displayed, this is 1 indexed, first line is the first start point so start after that
int bgIndex = 0; //background index
int textTiming = 0; //used for rendering each letter individually, ie it looks like its being typed out
String[] textLines = new String[999]; //used for each line of dialogue, this is the raw text in
String[] textLinesO = new String[999]; //used for each line of dialogue, this is after the commands are stripped
String[] levelEndCommands = new String[999]; //used for commands be ran at the end of each level
int[][] vnInfo = new int[999][5]; //used for stuff like who should be rendered, tint, etc
int commandIndex = 0; //used by the vn command handler to define which level should be skipped to
boolean vnScreenChanges = true; //used to denote whether or not a screen update is needed on the vn segments as to not render frames when nothing has changed
int scriptLength = 0; //used to determine length of script file when its loaded
int[] scriptStartPoints = new int[999]; //used to determine the start point of each script

//animation timing vars
int playerEngineTimer = 0;

//settings vars
boolean oneHitMode = true; //whether to set game to paused when player dies
boolean damageOnTop = false; //whether or not to render to damage on top of the player

//level editor vars
int scrollX = 0; //used for the scroll on the level editor
int[] levelEnemyType = new int[999]; //used to store the enemy types
int[] levelEnemyX = new int[999]; //used to store enemy x pos
int[] levelEnemyY = new int[999]; //used to store enemy y pos
int levelEnemyIndex = 0; //used for writing to the arrays
int levelEnemyTypeSelected = 0; //used to know which enemy type is selected
float displayX; //used for scrolling enemies
boolean levelEditorMode; //used for playtesting the level
 public void drawVN() {
  if (vnScreenChanges == true) {
  background(0);
  scanVNInfo();
  
  switch(vnInfo[textIndex][2]) { //left side vn portrait tint
    case 0:
    tint(255, 255, 255, 255);
    break;
    case 1:
    tint(255, 100);
    break;
  }
  switch(vnInfo[textIndex][0]) { //left side vn portrait image
    case 0:
    image(vnPlayer1r, 0, 0, 500, 500);
    break;
    case 1:
    image(vnPlayer2r, 0, 0, 500, 500);
    break;
    case 5:
    //image(vnSol1r, 0, 0, 500, 500);
    break;
    default:
    break;
  }
  switch(vnInfo[textIndex][3]) { //right side vn portrait tint
    case 0:
    tint(255, 255, 255, 255);
    break;
    case 1:
    tint(255, 100);
    break;
    default:
    break;
  }
  switch(vnInfo[textIndex][1]) { //right side vn portrait image
    case 0:
    image(vnPlayer1, 800, 0, 500, 500);
    break;
    case 1:
    image(vnPlayer2, 800, 0, 500, 500);
    break;
    case 5:
    image(vnSol1, 800, 0, 500, 500);
    break;
    case 10:
    image(vnEsence1, 800, 0, 500, 500);
    break;
    case 11:
    image(vnEsence2, 800, 0, 500, 500);
    break;
    case 12:
    image(vnEsence3, 800, 0, 500, 500);
    break;
    case 13:
    image(vnEsence4, 800, 0, 500, 500);
    break;
    case 20:
    image(vnCyana1, 800, 0, 500, 500);
    break;
    case 21:
    image(vnCyana2, 800, 0, 500, 500);
    break;
    case 22:
    image(vnCyana3, 800, 0, 500, 500);
    break;
    case 23:
    image(vnCyana4, 800, 0, 500, 500);
    break;
    case 30:
    image(vnVeda1, 800, 0, 500, 500);
    break;
    case 31:
    image(vnVeda2, 800, 0, 500, 500);
    break;
    case 32:
    image(vnVeda3, 800, 0, 500, 500);
    break;
    case 33:
    image(vnVeda4, 800, 0, 500, 500);
    break;
    default:
    break;
  }
  tint(255, 255, 255, 255); //reset image tint
  
  strokeWeight(2);
  stroke(255);
  fill(20, 20, 255);
  rect(20, 450, 1240, 250, 20);
  rect(1150, 650, 100, 40, 5);
  rect(1040, 650, 100, 40, 5);
  textSize(48);
  fill(255);
  noStroke();
  text(textLinesO[textIndex - 1], 35, 460, 1230, 250);
  textSize(32);
  text("SKIP", 1050, 680);
  text("NEXT", 1160, 680);
  
  vnScreenChanges = false; //finished rendering frame, do not render again unless changes to frame occur
  }
}

 public void scanVNCommands() { //looks for commands in the script text, this is run when text is advanced
  char[] ch = textLines[textIndex-1].toCharArray();
  if (ch[0] == '-' && ch[1] == 'l') { //load level
    commandIndex = (ch[3] - '0') * 10 + (ch[4] - '0'); //read the level index to load
    levelStart(commandIndex);
  } else if (ch[0] == '-' && ch[1] == 's') { //text start point
    textIndex++; //advance text to skip past start point line
  } else if (ch[0] == '-' && ch[1] == 'c') { //load a menu screen command
    commandIndex = (ch[3] - '0') * 10 + (ch[4] - '0'); //jump to menu screen
    screenIndex = commandIndex;
  } else if (ch[3] == '-' && ch[4] == 'a') { //load a new area (jump to level select)
    commandIndex = (ch[6] - '0') * 10 + (ch[7] - '0'); //jump to a script text section
    screenIndex = 2; //set screen to level select
    areaIndex = commandIndex; //set area to selected area
  }
}

 public void scanForStartPoints() {
  int index = 0; //used to increment the start points array, ie 0 would be the first start point, note the text after -s does not matter only the order in the file they appear
  for (int i = 0; i < scriptLength; i++) {
    char[] ch = textLines[i].toCharArray();
    if (ch[0] == '-' && ch[1] == 's') { //text blurb start point
      scriptStartPoints[index] = i+1+1; //textLines is a 1 incremented array, add another 1 so it starts the line after the start point line
      index++;
    }
  }
}

 public void advanceVNText() { //moves vn forward, reads commands, etc
  textIndex++; //advance the text script
  scanVNCommands();
  vnScreenChanges = true; //trigger a new vn frame rendering
  keyInput[4] = false; //release space key
}

 public void scanVNInfo() { //scans the script text for the vn portrait info
  char[] ch = textLines[textIndex-1].toCharArray();
  if (ch[0] != '-') { //ensure line is not a command
    vnInfo[textIndex][0] = (ch[0] - '0') * 10 + (ch[1] - '0'); //left vn portrait
    vnInfo[textIndex][1] = (ch[3] - '0') * 10 + (ch[4] - '0'); //right vn portrait
    vnInfo[textIndex][4] = (ch[6] - '0'); //tint, who is 
    
    //translate into vnInfo format that is used in drawVN
    if (vnInfo[textIndex][4] == 0) { //left side talking
    vnInfo[textIndex][2] = 0;
    vnInfo[textIndex][3] = 1;
  } else if (vnInfo[textIndex][4] == 1) { //right side talking
    vnInfo[textIndex][2] = 1;
    vnInfo[textIndex][3] = 0;
  } else if (vnInfo[textIndex][4] == 2) { //no one talking
    vnInfo[textIndex][2] = 1;
    vnInfo[textIndex][3] = 1;
  }
  
  char[] chStripped = new char[ch.length-7]; //makes a new char array for text stripping
  for(int i = 7; i < ch.length; i++) { //strips the first 7 chars
    chStripped[i-7] = ch[i];
  }
  textLinesO[textIndex-1] = String.valueOf(chStripped); //dumps the char into a string
} else textLinesO[textIndex-1] = "this line is a command [error]";
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "edge_of_solaris" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
